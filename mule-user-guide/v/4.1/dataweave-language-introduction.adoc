= About DataWeave Scripts
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping

DataWeave is the primary data transformation language for Mule flows. You can write standalone DataWeave scripts in Transform Message components, or you can write inline DataWeave expressions to transform data _in-place_ and dynamically set the value of various properties, such as configuration fields in an event processor or global configuration element. Inline DataWeave expressions are enclosed in `#[ ]` code blocks. For example, you can use a DataWeave expression to set conditions in a Choice router or to set the value of a Set Payload or Set Variable component.

The DataWeave code in this example sets a timestamp variable to the current time using the DataWeave `now()` function:

.Example: Simple Inline DataWeave Script
[source, dataweave, linenums]
----
<set-variable value="#[now()]" variableName="timestamp" doc:name="Set timestamp" />
----

You can also store DataWeave code in external files and read them in to other DataWeave scripts, or you can factor DataWeave code into modules (libraries) of reusable DataWeave functions that can be shared by all the components in a Mule app.


== The Structure of DataWeave Scripts
DataWeave scripts and files are divided into two main sections:

* The Header, which defines directives that apply to the body expression (optional).

* The Body, which contains the expression to generate the output structure.

When you include a header, the header appears above the body separated by a delimiter consisting of three dashes: `---`.

Here is an example DataWeave file with an output directive declared in the header, followed by a DataWeave expression to create a user object that contains two child key/value pairs:

.Example: Simple DataWeave Script
[source, dataweave, linenums]
----
%dw 2.0
output application/xml
---
{
  user: {
    firstName: payload.user_firstname,
    lastName: payload.user_lastName
  }
}
----

== DataWeave Header

This example shows keywords (such as `import` and `var`) you can use for header directives.

.DataWeave Script
[source, dataweave, linenums]
----
%dw 2.0
import * from dw::core::Arrays
var myVar=13.15
fun toUser(obj) = {
  firstName: obj.field1,
  lastName: obj.field2
}
type Currency = String { format: “##“}
ns msg http://www.mulesoft.com/anypoint/SOA/message/v1.0
output application/xml
---
/*
 * Body here.
 * /
----

* `%dw`: DataWeave version is optional. Default is `2.0`.
+
Example: `%dw 2.0`
+
* `output`: Commonly used directive that specifies the mime type that the script outputs.
+
Example: `output application/xml`
+
Valid values: link:dataweave-formats[Mime Types that are Supported by DataWeave].
+
Default: If no output is specified, the default output is determined by an algorithm that examines the inputs (payload, variables, and so on) used in the script:
+
. If there is no input, the default is `output application/java`.
. If all inputs are the same mime type, the script outputs to the same mime type. For example, if all input is `application/json`, then it outputs `output application/json`.
. If the mime types of the inputs differ, and no output is specified, the script throws an exception so that you know to specify an output mime type.
+
Note that only one output type can be specified.
+
* `import`: For importing a DataWeave function module. See link:dw-functions[DataWeave Functions].
* `var`: Global variables for defining constants that you can reference throughout the body of the DataWeave script:
+
.Example
[source, dataweave, linenums]
----
%dw 2.0
var conversionRate=13.15
output application/json
---
{
 price_dollars: payload.price,
 price_localCurrency: payload.price * conversionRate
}
----
+
* `type`: For specifying a custom type that you can use in the expression.
+
* `ns`: Namespaces, used to import a namespace.
+
Example: `ns msg +http://www.mulesoft.com/anypoint/SOA/message/v1.0+`
+
* `fun`: For creating custom functions that can be called from within the body of the script.
+
.Example
[source, dataweave, linenums]
----
%dw 2.0
output application/json
fun toUser = (user) -> {firstName: user.name, lastName: user.lastName}
---
{
  user: toUser(payload)
}
----

== DataWeave Body

The DataWeave body contains an expression that generates the output structure. Note that MuleSoft provides a canonical way for you to work on data with the DataWeave model: a query, transform, build process.

Here is simple example that provides JSON input for a DataWeave script:

.Example: JSON Input
[source,JSON,linenums]
----
{
    "message": "Hello world!"
}
----

This DataWeave script takes the entire payload of the JSON input above and outputs it to the `application/xml` format.

.Example: DataWeave Script
[source,DataWeave,linenums]
----
%dw 2.0
output application/xml
---
payload
----

The next example shows the XML output produced by the DataWeave script:

.Example: XML Output
[source,XML,linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<message>Hello world!</message>
----

The script above successfully transforms the JSON input to XML output.

Note, however, that a script can throw errors due to DataWeave coding errors and due to formatting errors. So when transforming one data format to another, it is important to keep in mind the constraints of the formats.

For example, if you use the next script in the attempt to transform the JSON input below to XML, you will receive an error (`Unexpected internal error`) because the JSON input lacks a single root.

.Example: Script that Outputs application/xml
[source,DataWeave,linenums]
----
%dw 2.0
output application/xml
---
payload
----

[[json_input]]
.Example: JSON Input
[source,JSON,linenums]
----
{
    "size" : 1,
    "person": {
      "name": "Yoda"
    }
}
----

A good mental model for approaching the transformation script is to normalize the input to the JSON-like <<dataweave-formats#format_dataweave, `application/dw`>> format. In fact, if you get an error, you can transform your input to `application/dw` to see if the script throws an error or not. If not, then the error is likely a formatting error.

To isolate the error to an output formatting error, instead of a syntax problem in your DataWeave code, you can change the output format to `application/dw` like this:

.Example: DataWeave Script that Outputs application/dw
[source,DataWeave,linenums]
----
%dw 2.0
output application/dw
---
payload
----

Now the script produces `application/dw` output without an error:

.Example: application/dw Output
----
{
  size: 1,
  person: {
    name: "Yoda"
  }
}
----

So you know that the error is specific about XML data structures. Now notice that the `application/dw` output above does not provide a single root element, as required by the XML format. So, to fix the script for XML output, you need to provide a single root element, for example:

.Example: Script that Outputs application/xml
[source,DataWeave,linenums]
----
%dw 2.0
output application/xml
---
{
    "myroot" : payload
}
----

Now the output meets the requirements, so when you change the output directive back to `application/xml`, the result produces valid XML output.

.Example: XML Output Containing a Single XML Root
[source,XML,linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<myroot>
  <size>1</size>
  <person>
    <name>Yoda</name>
  </person>
</myroot>
----

=== Including Headers in Inline DataWeave Scripts

You can include header directives when you write inline DataWeave scripts by flattening all the lines in the DataWeave script into a single line. For smaller DataWeave scripts, this allows you to quickly apply header directives (without having to add a separate Transform Message component to set a variable), then substitute the variable in the next Event processor.

For example, here is the Mule configuration XML to create the same valid XML output as the previous Transform Message component:

.Example: Simple Inline DataWeave Script
[source, dataweave, linenums]
----
<set-payload value="#[output application/xml --- { myroot: payload } ]" doc:name="Set Payload" />
----

Note that the DataWeave documentation provides numerous <<see_also, transformation examples>>.

// TODO: NEED MORE INFO HERE... show XML vs DW vs JSON

////
Note that the output of a DataWeave expression can include these data types:

* Simple Values: Strings and numbers, for example: `Some String`, `18`.
* Arrays: A sequence of comma separated values, for example: `1, 2, 3`. The values can be any supported data type.
* Objects: A collection of key-value pairs, for example: `{"key": "some value"}`. The values can be any supported data type.
////

//== Transforming Data Formats in Inline DataWeave Scripts

== DataWeave Comments
Comments that use a Java-like syntax are also accepted by DataWeave.
----
// My single-line comment here.

/*
 * My multi-line comment here.
 */
----

== dwl File

In addition to specifying DataWeave scripts in the Transform and other components, you can also specify the scripts in a `.dwl` file. In Studio projects, your script files are stored in `src/main/resources`.

[[see_also]]
== See Also

link:dataweave-selectors[DataWeave Selectors]

link:dw-functions[DataWeave Functions]

link:dataweave-cookbook[DataWeave Cookbook]

link:dataweave-formats[Data Formats Supported by DataWeave]

link:dataweave-types#functions-and-lambdas[Functions and Lambdas]

= About DataWeave Scripts
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping

DataWeave scripts are divided into two sections divided by a triple-dash delimiter (`---`):

* Header: Contains directives to apply to the expression in the body. The example shows some common directives (`%dw 2.0` and `output application/xml`).
* Body: Contains an expression for generating the output structure.

.Example: Simple DataWeave Script
[source, dataweave, linenums]
----
%dw 2.0
output application/xml
---
{
  user: {
    name: payload.user_name,
    lastName: payload.user_lastName
  }
}
----

== DataWeave Header

This example shows keywords (such as `import` and `var`) you can use for header directives.

.DataWeave Script
[source, dataweave, linenums]
----
%dw 2.0
import * from dw::core::Arrays
var myVar=13.15
fun toUser(obj) = {
  firstName: obj.field1,
  lastName: obj.field2
}
type Currency = String { format: “##“}
ns msg http://www.mulesoft.com/anypoint/SOA/message/v1.0
output application/xml
---
/*
 * Body here.
 * /
----

* `%dw`: DataWeave version is optional. Default is `2.0`.
+
Example: `%dw 2.0`
+
* `output`: Commonly used directive that specifies the mime type that the script outputs.
+
Example: `output application/xml`
+
Valid values: link:dataweave-formats[Mime Types that are Supported by DataWeave].
+
Default: If no output is specified, the default output is based on an algorithm that examines the inputs (payload, variables, and so on) used in the script:
+
. If the there is no input, the default is `output application/java`.
. If all inputs are the same mime type, the script outputs to the same mime type. For example, if all input is `application/json`, then it outputs `output application/json`.
. If the mime types of the inputs differ, and no output is specified,  the script throws an exception so that you know to specify an output mime type.
+
Note that only one output type can be specified.
+
* `import`: For importing a DataWeave function module. See link:dw-functions[DataWeave Functions].
* `var`: Global variables for defining constants that you can reference throughout the body of the DataWeave script:
+
.Example
[source, dataweave, linenums]
----
%dw 2.0
var conversionRate=13.15
output application/json
---
{
 price_dollars: payload.price,
 price_localCurrency: payload.price * conversionRate
}
----
+
* `type`: For specifying a custom type that you can use in the expression.
+
* `ns`: Namespaces, used to import a namespace.
+
Example: `ns msg +http://www.mulesoft.com/anypoint/SOA/message/v1.0+`
+
* `fun`: For creating custom functions that can be called from within the body of the script.
+
.Example
[source, dataweave, linenums]
----
%dw 2.0
output application/json
fun toUser = (user) -> {firstName: user.name, lastName: user.lastName}
---
{
  user: toUser(payload)
}
----

== DataWeave Body

The DataWeave body contains an expression that generates the output structure. Note that MuleSoft provides a canonical way for you to work on data with the DataWeave model: a query, transform, build process.

A good mental model for approaching the transformation script is to normalize the input to <<dataweave-formats#format_dataweave, `application/dw`>>. This can help you determine whether an error is a formatting or a scripting error. So, for example, you might normalize your `application/xml` input to `application/dw` before providing your script that outputs to JSON (`application/json`).

.Example: JSON Input
[source,JSON,linenums]
----
{
    "size" : 1,
    "person": {
      "name": "Nial"
    }
}
----

The DataWeave script outputs the DataWeave format (`application/dw`).

.Example: DataWeave Script that Outputs application/dw
[source,DataWeave,linenums]
----
%dw 2.0
output application/dw
---
payload
----

The script produces `application/dw` output without an error.

.Example: application/dw Output
----
{
  size: 1,
  person: {
    name: "Nial"
  }
}
----

However, if you output the JSON to XML, you will receive an error (`Unexpected internal error`) because the JSON input lacks a single root. So the error is a formatting error.

.Example: Script that Outputs application/xml and Produces an Error
[source,DataWeave,linenums]
----
%dw 2.0
output application/xml
---
payload
----

To fix the script, you need to provide a single XML root, for example:

.Example: Script that Outputs application/xml
[source,DataWeave,linenums]
----
%dw 2.0
output application/xml
---
{
    "myroot" : payload
}
----

.Example: XML Output Containing a Single XML Root
[source,XML,linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<myroot>
  <size>1</size>
  <person>
    <name>Nial</name>
  </person>
</myroot>
----

The DataWeave documentation provides numerous <<see_also, other examples>>.

// TODO: NEED MORE INFO HERE... show XML vs DW vs JSON

////
Note that the output of a DataWeave expression can include these data types:

* Simple Values: Strings and numbers, for example: `Some String`, `18`.
* Arrays: A sequence of comma separated values, for example: `1, 2, 3`. The values can be any supported data type.
* Objects: A collection of key-value pairs, for example: `{"key": "some value"}`. The values can be any supported data type.
////

== DataWeave Comments
Comments that use a Java-like syntax are also accepted by DataWeave.
----
// My single-line comment here.

/*
 * My multi-line comment here.
 */
----

== dwl File

In addition to specifying DataWeave scripts in the Transform and other components, you can also specify the scripts in a `.dwl` file. In Studio projects, your script files are stored in `src/main/resources`.

[[see_also]]
== See Also

link:dataweave-selectors[DataWeave Selectors]

link:dw-functions[DataWeave Functions]

link:dataweave-cookbook[DataWeave Cookbook]

link:dataweave-formats[Data Formats Supported by DataWeave]

link:dataweave-types#functions-and-lambdas[Functions and Lambdas]


////
== See Also
////

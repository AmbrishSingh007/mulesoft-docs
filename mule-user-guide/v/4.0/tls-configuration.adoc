= TLS Configuration
:keywords: tls, trust, store, https, ssl, secure messages, encryption, trust store, key store, keystore, truststore

Mule Runtime 4.x supports Transport Layer Security (TLS) 1.1/1.2. 
TLS is a cryptographic protocols that provides communications security over a computer network. TLS supports many different methods for exchanging keys, encrypting data, and authenticating message integrity. This topic describes the methods supported by Mule and how to configure TLS in Mule apps.

Mule provides a TLS configuration element for setting up TLS. This element is independent of any module or transport. For example, you can configure TLS for use with HTTP (server and client), FTPS (client), Email (client), Sockets (client).




== To Generate Keystores and Truststores

A TLS service needs to have a private key and a public certificate. The private key never leaves the server. The public certificate is exposed through TLS so clients can verify if they trust the server.

Certificates can be generated by a well-known Certificate Authority (CA) or can be generated locally without external approval (self-signed certificates). Certificates generated from Certificate Authorities include digital signatures and are usually accepted as trusted by any client that includes the CA certificate in its repository of trusted certificates (trust store).

For Mule products, certificates and private keys must be imported into Java keystore files. Trust store files are also keystores that by convention only include public certificates of trusted servers.

The 'tls:trust-store' and 'tls:key-store' elements must reference existing certificates. If you don't provide any values for the trust-store, the default Java trust store is used. The default trust store is updated with the Java version, so it's recommended that you use an updated Java version to be sure it includes updates to well known CA certificates.

Mule supports the following keystores types, and possibly more. MuleSoft has tested only the following types:

* JCEKS
* PKCS12
* JKS

The keystore types are configurable at the JRE level. The attribute is a string. Studio just helps you out by pointing out usual values. The type and algorithm attributes are more advanced and should not be featured in examples, IMO.

To generate your own certificates, you can do so by following the steps below using  link:http://docs.oracle.com/javase/8/docs/technotes/tools/#security[Java Keytool].

////
=== Generating a Keystore

. To generate a keystore that exposes your server's credentials, run the command:

+
[source, code, linenums]
----
keytool -genkey -alias serverkey -keyalg RSA -keystore server.jks
----

The generated keystore will contain a private key and a public certificate. This certificate is self signed so it will be not be trusted by clients unless you share the public certificate with them.

Keytool generates certificates using the DSA algorithm by default. You can instead specify it to use the RSA algorithm as in the example above through the '-keyalg RSA' argument.

. You will then be prompted for additional details, along with the store password and key password.
​
. Once this is done, you must export the server's certificate from the keystore so that it can be shared with clients. To do this, use the following command:
+
[source, code, linenums]
----
keytool -export -alias serverkey -keystore server.jks -file server_cert.cer
----

[NOTE]
There is no default Java key store in the standard JDK distribution, so you must generate your own certificates in order to use this element.

If you also wish to get signed by a Certification Authority (CA), you must export your certificate in the standard CSR format. To do so you can run this command:

[source, code, linenums]
----
keytool -certreq -keystore server.jks -alias example.com -file certificate_file
----

Here, '-file' refers to the name you wish to give to your certificate file. Once generated, send the CSR file to the CA and follow their instructions to obtain their signature.

Once you have obtained the CA's signature, you can import the signed certificate file through the following command:

[source, code, linenums]
----
keytool -import -keystore keystore -alias example.com -file signed_certificate_file
----

The alias you assign when importing must not be linked to any existing key or the process will fail.

=== Generating a Trust Store

The standard JRE distribution includes a *default trust store* with certificates for several major certificate authorities (CA's) which is used by default in the 'tls:trust-store' element, but you can generate your own if you want to have greater security or when using self-signed certificates.

. To create a trustStore, run the command:
+
[source, code, linenums]
----
keytool -import -alias serverkey -keystore client_truststore.ts -file server_cert.cer
----

The client will trust the server if a chain of trust can be established, either directly to the server (in case its certificate is in the trust store) or through a signing CA whose certificate is present in the trust store, failing otherwise. This means that a trust store must be defined when using self-signed certificates.

////

== To Configure TLS

Adding a trust store or a key store to a TLS configuration implicitly implements the corresponding kind of authentication. Adding both a keystore and a trust store to the configuration implicitly implements *two way TLS authentication*, also known as *mutual authentication*.

A trust store contents differ depending on its location:

* Server side: the trust store contains certificates of the trusted clients.
* Client side: the trust store contains certificates of the trusted servers.

The key store contains the private and public key of the server.

The keystore may contain two passwords, as one of them can serve for accessing the entire keystore file. The other (keyPassword) may be additionally needed to access the server’s private key, which is inside this file.

== Server Side Configuration

If the `tls:context` is empty (no key-store or trust-store defined), then the default values of the JVM will be used, which likely already include a trust store with certificates for all the major certifying authorities.

If the client requires a certificate from the server that it is trying to connect to, then the `<tls:trust-store>` element must be added, with the path field set to the location of the trust store file that contains the certificates of the trusted servers.

If the server validates certificates from the clients, then the `<tls:key-store>` element should be also added with the path field set to the location of the keystore file that contains the private/public keys of the client.

////
A `request-config` element from the new HTTP connector may reference a `tls:context` element in order to implement HTTPS.
////

== Client Side Configuration

The `tls:context` is required to at least contain a `tls:key-store` element, with the path field set to the location of the keystore file that contains the private/public keys of the server.

If the server needs to validate certificates from clients, then a `tls:trust-store` element should also be added, with the path field set to the location of the trust store file that contains the certificates of the trusted clients.

////
A listener-config element from the new HTTP connector may reference a `tls:context` element in order to configure HTTPS. 
////

== XML Reference for TLS

This following tls:context element and attributes define TLS communication in a Mule app. You typically define a TLS configuration globally and reuse it. You refer to the global definition to apply it to a specific use, such as listening for or sending a request.

=== Globally Defined TLS Element

The `tls:context` element defines a configuration for TLS, which can be used from both the client and server sides. It can be referenced by other configuration objects of other modules (or defined as a nested element of one of them).

Inside it, you can include two nested elements: `key-store` and `trust-store`. You don't need to include both, but at least one of the two must be present.

[source, xml, linenums]
----
<tls:context name="customContext">
    <tls:trust-store path="trustStore" password="mulepassword"/>
    <tls:key-store path="clientKeystore" keyPassword="mulepassword"
password="mulepassword"/>
 </tls:context>
----


=== Nested TLS Element Listener Example

[source, xml, linenums]
----
<http:listener-config name="globalConfig" protocol="HTTPS" host="localhost" port="8443">
        <tls:context>
            <tls:trust-store path="trustStoreFile" password="1234"/>
            <tls:key-store path="keyStoreFile" keyPassword="123" password="456"/>
        </tls:context>
    </http:listener>
----

=== Nested TLS Element Request Example

[source, xml, linenums]
----
<http:request-config name="globalConfig" protocol="HTTPS" host="localhost" port="8443">
        <tls:context>
            <tls:trust-store path="trustStoreFile" password="1234"/>
            <tls:key-store path="keyStoreFile" keyPassword="123" password="456"/>
        </tls:context>
    </http:request-config>
----


=== Attributes of the tls-context Element

[cols="10a,80a,10a"]
|===
|*Attribute* |*Description* |*Required*
|enabledProtocols| Specifies which protocols to enable, out of the list of protocols set in the <<Global TLS configuration>> |Optional
|enabledCipherSuites | Specifies which cipher suites to enable, out of the list in <<Global TLS configuration>> |Optional
|===

=== Attributes of the trust-store Element

[cols="10a,80a,10a"]
|===
|*Attribute* |*Description* |*Required*
|path |Path to the file that contains the trust store. |Required
|type |The type of the trust store (default JKS) + |Optional
|password |The trust store password. + |Optional
|algorithm |The algorithm used in the trust store (default SunX509) |Optional
|insecure | Boolean that determines if validations against the trust-store are to be done at all. If set to `true`, all certificates are accepted without any validation. If not set, it defaults to 'false' |Optional
|===

Setting 'insecure' to 'true' renders connections vulnerable to attacks. Its use is only recommended for prototyping and testing purposes.

=== Attributes of the key-store Element

[cols="10a,80a,10a"]
|===
|*Attribute* |*Description* |*Required*
|path |Path to the file that contains the key store. |Required
|type |The type of the key store (default JKS) |Optional
|password |The key store password |Optional
|keyPassword |The key manager password (password for the private key inside the key store) |Optional
|algorithm |The algorithm used in the key store (default SunX509) |Optional
|===

== Protocols and Cipher Suites

When a TLS communication takes place between two systems, a negotiation determines which protocol and cipher suite are used. 

You can configure protocols and cipher suites in the Mule `/conf` directory in `$MULE_HOME. Select one of two files for fine-tuning the configuration by manually setting which cipher suites and protocols Mule will use:

* tls-default.conf
+
Allows fine-tuning when Mule is not configured to run in Federal Information Processing Standards (FIPS) security mode.
+
* tls-fips140-2.conf
+
Allows fine-tuning when Mule is running in FIPS security mode.


[TIP]
$MULE_HOME` is the directory where your Mule installation resides, for example `/opt/mule-3.4.1`.

Open the relevant file and comment or uncomment items in the lists to manually configure the allowed cipher suites and SSL protocols. If you make no changes to these files, Mule allows the configured security manager to select cipher suites and protocols.

The list of protocols and cipher suites that you set in these configuration files can then be constrained locally by what is set up in an individual `tls:context` element if those parameters are defined.

Only those enabled on both ends can be used. 

If you do not configure protocols and cipher suites, the default Java environment protocol and cipher suites are used.

If you configure multiple protocols and cipher suites in the global TLS configuration file, you can then and then specify a subset in the tls:context element for use by TLS. You configure the protocols and cipher suites in the enabledProtocols and enabledCipherSuites in the tls:context element.

In the tls:context element, you cannot reference protocols or cipher suites here that are not included in your global TLS configuration file. In the tls:context element, you can set enabledProtocols and enabledCipherSuites to the value `default`. In this case, TLS uses the following protocols and cipher suites:

* Those configured in your global TLS configuration if it exists
* The defaults provided by your Java environment if a global TLS configuration does not exist.

Cipher suite names can be long and impact the readability of your XML code. To improve readability, keep these names in an external properties file in your Mule project and refer to it.

image:tls-cipher-property.png[cipher suite]

You can then reference your properties using the following syntax:

[source, xml, linenums]
----
<tls:context name="serverTlsContext" enabledCipherSuites="${myCipherSuites}" >
----


== Using a UI to Configure TLS

You can configure TLS in Studio and Design Center. For example, you can set up TLS in the HTTP Connector Global configuration or Web Service Consumer > Security.

== See Also

* TBD
* link:/mule-user-guide/v/3.9/configuring-properties[external properties file]

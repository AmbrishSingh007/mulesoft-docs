= Mime Types Supported by DataWeave
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping

DataWeave can read and write many types of data formats, such as JSON, XML, and many others. It also accepts format-specific properties, such as CSV input and output (for example, the `separator` delimiter and `encoding` properties) and for a Cobol copybook, the path to a schema file (the `schemaPath`).

// TODO: POINT TO TOPIC THAT SHOWS SYNTAX FOR ADDING PROPERTIES, e.g.,
// write(myObj, “application/json”,{indent:false}

DataWeave supports these formats for input and output:

[cols="2,2", options="header"]
|===
| Mime Type | Supported Formats

| `application/csv`
| <<format_csv>>

| `application/dw`
| <<format_dataweave>> (for testing a DataWeave expression)

| `multipart/form-data`
| <<format_form_data>> (for binary or large payloads)

| `application/flatfile`
| <<format_flat_file>>, <<format_cobol_copybook>>, <<format_fixed_width>>

| `application/java`
| <<format_java>>, <<format_enum>>

| `application/json`
| <<format_json>>

| `application/octet-stream`
| <<format_binary_data>>

| `application/xml`
| <<format_xml>>, <<format_cdata>>

| `application/xlsx`
| <<format_excel>>

| `application/x-www-form-urlencoded`
| <<format_url_encoded>>

| `text/plain`
| For plain text.
|===
// TODO: PLAIN TEXT SECTION? <<format_plain_text>>

[[format_cobol_copybook]]
== Cobol Copybook

Mime Type: `application/flatfile`

// TODO: <<flat file>>
A Cobol copybook is technically a type of flat file. The copybook provides information about the layout of records and fields in a Cobol data file.

The Transform component provides settings that are tailored to Cobol copybook format. For example, you can import a Cobol schema into the Transform component and use that schema for your Copybook transformations.

=== Reader Properties (for Cobol Copybook)

When defining an input of type Copybook, there are a few optional parameters you can add in the XML definition of your Mule project to customize how the data is parsed.

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`schemaPath` | string | | Location in your local disk of the schema file used to parse your input
|`segmentIdent` |string |  | In case the schema file defines multiple different structures, this field selects which to use
|`missingValues` | string | nulls | How missing values are represented in the input data:

* `none`: treat all data as actual values
* `spaces`: interpret a field consisting of only spaces as a missing value
* `zeroes`: interpret numeric fields consisting of only '0' characters and character fields consisting of only spaces as missing values
* `nulls`: interpret a field consisting only of 0 bytes as a missing value

| `recordParsing` | string | strict a| expected separation between lines/records:

* `strict`: line break expected at exact end of each record
* `lenient`: line break used but records may be shorter or longer than schema specifies
* `noTerminator`: means records follow one another with no separation
|===

Note that schemas with type `Binary` or `Packed` don't allow for the detection of line breaks, so setting `recordParsing` to `lenient` only allow for long records to be handled, not short ones. These schemas only work with certain single-byte character encodings (so not with UTF-8 or any multibyte format).

////
You can set these properties through the Transform component or through the XML of your Mule app.

XML example:

[source, xml, linenums]
----
<dw:input-payload mimeType="application/flatfile" >
  <dw:reader-property name="schemaPath" value="myschema.ffs"/>
  <dw:reader-property name="segmentIdent" value="structure1"/>
</dw:input-payload>
----
////

=== Writer Properties (for Cobol Copybook)

When defining an output of type Copybook, there are a few optional parameters you can add to the DataWeave output directive to customize how the data is written:

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`schemaPath` |string | |Path where the schema file to be used is located
|`segmentIdent` |string | |In case the schema file defines multiple formats, indicates which of them to use
|`encoding` |string | UTF-8 | Output character encoding

|`missingValues`| string | nulls | How to represent optional values missing from the supplied map:

* `spaces`: fill the field with spaces
* `nulls`: use 0 bytes

|`recordTerminator` | string | Standard Java line termination for the system | Termination for every line/record. In Mule runtime versions 4.0.4 and older, this is only used as a separator when there are multiple records. Possible values: `lf, cr, crlf, none`. Values translate directly to character codes (`none` leaves no termination on each record).
|`trimValues` |boolean |`false` |Trim string values longer than field length by truncating trailing characters
|===

.Example: output Directive
[source,DataWeave,linenums]
----
output application/flatfile schemaPath="src/main/resources/schemas/QBReqRsp.esl", structureIdent="QBResponse"
----

[[cobol_metadata]]
=== Defining a Metadata Type (for Cobol Copybook)

In the Transform component, you can define a Copybook type through the following method:

. Right-click the input payload in the Transform component, and select Set Metadata to open the Set Metadata Type dialog.
. Provide a name for your copybook metadata, such as `copybook`.
. Import your copybook schema.
. Click Select.
+
.Importing a Copybook Schema
image:copybook_import.png[Importing a Copybook File]
+

For example, assume that you have a copybook schema file (`mailing-record.cpy`) that looks like this:

----
01  MAILING-RECORD.
    05  COMPANY-NAME            PIC X(30).
    05  CONTACTS.
        10  PRESIDENT.
            15  LAST-NAME       PIC X(15).
            15  FIRST-NAME      PIC X(8).
        10  VP-MARKETING.
            15  LAST-NAME       PIC X(15).
            15  FIRST-NAME      PIC X(8).
        10  ALTERNATE-CONTACT.
            15  TITLE           PIC X(10).
            15  LAST-NAME       PIC X(15).
            15  FIRST-NAME      PIC X(8).
    05  ADDRESS                 PIC X(15).
    05  CITY                    PIC X(15).
    05  STATE                   PIC XX.
    05  ZIP                     PIC 9(5).
----
Note that copybook schemas must always begin with a `01` entry. A separate record type is generated for each `01` definition in your copybook (there must be at least one 01 definition for the copybook to be usable, so add one using an arbitrary name at the start of the copybook if none is present). If there are multiple `01` definitions in the copybook, you can select which definition to use in the transform from the dropdown list.

When you import the schema, the Transform component converts the schema to an FFD schema that it stores in the `src/main/resources/schema` folder of your Mule project. In flat file format, the copybook schema above looks like this:

----
form: COPYBOOK
id: 'MAILING-RECORD'
values:
- { name: 'COMPANY-NAME', type: String, length: 30 }
- name: 'CONTACTS'
  values:
  - name: 'PRESIDENT'
    values:
    - { name: 'LAST-NAME', type: String, length: 15 }
    - { name: 'FIRST-NAME', type: String, length: 8 }
  - name: 'VP-MARKETING'
    values:
    - { name: 'LAST-NAME', type: String, length: 15 }
    - { name: 'FIRST-NAME', type: String, length: 8 }
  - name: 'ALTERNATE-CONTACT'
    values:
    - { name: 'TITLE', type: String, length: 10 }
    - { name: 'LAST-NAME', type: String, length: 15 }
    - { name: 'FIRST-NAME', type: String, length: 8 }
- { name: 'ADDRESS', type: String, length: 15 }
- { name: 'CITY', type: String, length: 15 }
- { name: 'STATE', type: String, length: 2 }
- { name: 'ZIP', type: Integer, length: 5, format: { justify: ZEROES, sign: UNSIGNED } }
----

After importing the schema, you can use the `schemaPath` property to reference the flat file through the `output` directive. For example: `output application/flatfile  schemaPath="src/main/resources/schemas/mailing-record.ffd"`

[[format_csv]]
== CSV

Mime Type: `application/csv`

CSV content is modeled in DataWeave as a list of objects, where every record is an object and every field in it is a property. For example:

.DataWeave Script that Outputs CSV
[source,dataweave,linenums]
----
%dw 2.0
output application/csv
---
[
  {
    "Name":"Mariano",
    "Last Name":"De achaval"
  },
  {
    "Name":"Leandro",
    "Last Name":"Shokida"
  }
]
----

.CSV Output
[source,csv,linenums]
----
Name,Last Name
Mariano,De achaval
Leandro,Shokida
----

=== Reader Properties (for CSV)

In CSV, you can assign any special character as the indicator for separating fields, toggling quotes, or escaping quotes. Make sure you know what special characters are being used in your input so that DataWeave can interpret it correctly.

When defining an input of type CSV, there are a few optional parameters you can add in the XML definition of your Mule project to customize how the data is parsed.

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`separator` |char | `,` |Character that separates one field from another
|`quote` |char | `"` |Character that delimits the field values
|`escape` |char | `\` |Character used to escape occurrences of the separator or quote character within field values
|`bodyStartLineNumber`| number | `0` | The line number where the body starts.
|`ignoreEmptyLine` |bool | `true` | defines if empty lines are ignored
|`header` |bool |`true` |Indicates if the first line of the output shall contain field names
|`headerLineNumber` | number | `0` | the line number where the header is located
|`streaming` | bool | `false` | Used for streaming input CSV. (Use only if entries are accessed sequentially.)
|===

* When `header=true` you can then access the fields within the input anywhere by name, for example: `payload.userName`.
* When `header=false` you must access the fields by index, referencing first the entry and then the field, for example: `payload[107][2]`

////
TODO: NEEDS UPDATE
* XML example:
+
[source,xml,linenums]
----
<dw:transform-message metadata:id="33a08359-5085-47d3-aa5f-c7dd98bb9c61"
  doc:name="Transform">
    <dw:input-payload
      <!-- Boolean that defines if the first line in the data contains headers -->
      <dw:reader-property name="header" value="false" />
      <!-- Character that separates fields, `','` by default -->
      <dw:reader-property name="separator" value="," />
      <!-- Character that defines quoted text, `" "` by default -->
      <dw:reader-property name="quote" value="&quot;" />
      <!-- Character that escapes quotes, `\` by default -->
      <dw:reader-property name="escape" value="\" />
    </dw:input-payload>
 		<dw:set-payload>
        <![CDATA[
            %dw 2.0
            output application/java
            ---
            // Your transformation script goes here
        ]]>
    </dw:set-payload>
</dw:transform-message>
----
+
* Transform component example:
image::dataweave-formats-580be.png[]
// TODO CHECK IMAGE
////

=== Writer Properties (for CSV)

When defining an output of type CSV, there are a few optional parameters you can add to the output directive to customize how the data is parsed:

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`separator` |char |, |Character that separates one field from another
|`encoding` |string | |The character set to be used for the output
|`quote` |char |" |Character that delimits the field values
|`escape` |char | \ |Character used to escape occurrences of the separator or quote character within field values
|`lineSeparator`|string | system line ending default | line separator to be used. Example: "\r\n"
|`header` |bool |true |Indicates if the first line of the output shall contain field names
|`quoteHeader` |bool |false |Indicates header values should be quoted
|`quoteValues` |bool |false |Indicates if every value should be quoted whether or not it contains special characters within
|===

All of these parameters are optional. A CSV output directive might for example look like this:

.Example: output Directive
[source,DataWeave,linenums]
---------------------------------------------------------------------
output text/csv separator=";", header=false, quoteValues=true
---------------------------------------------------------------------

=== Defining a Metadata Type (for CSV)

In the Transform component, you can define a CSV type through the following methods:

* By providing a sample file.
* Through a graphical editor that allows you to set up each field manually.
+
image::dataweave-formats-4a556.png[]

[[format_dataweave]]
== DataWeave

Mime Type: `application/dw`

The DataWeave format is the canonical format for all transformations. Using it can helpful for understanding how input data is interpreted before it is transformed to a new format.

This example shows how XML input is expressed in the DataWeave format.

.Input XML
[source,XML,linenums]
----
<employees>
  <employee>
    <firstname>Mariano</firstname>
    <lastname>DeAchaval</lastname>
  </employee>
  <employee>
    <firstname>Leandro</firstname>
    <lastname>Shokida</lastname>
  </employee>
</employees>
----

.Output in DataWeave Format
[source,dataweave,linenums]
----
{
  employees: {
    employee: {
      firstname: "Mariano",
      lastname: "DeAchaval"
    },
    employee: {
      firstname: "Leandro",
      lastname: "Shokida"
    }
  }
} as Object {encoding: "UTF-8", mimeType: "text/xml"}
----

[[format_excel]]
== Excel

Mime Type: `application/xlsx`

Only `.xlsx` files are supported (Excel 2007). `.xls` files are not supported by Mule runtime.

// TODO: IS THIS ACCURATE?
An Excel workbook is a sequence of sheets. In DataWeave, this is mapped to an object where each sheet is a key. Only one table is allowed per Excel sheet. A table is expressed as an array of rows. A row is an object where its keys are the columns and the values the cell content.

.Input

image:dataweave-formats-exceltable.png[]

.DataWeave Script that Outputs XLSX
[source,dataweave,linenums]
----
output application/xlsx header=true
---
{
  Sheet1: [
    {
      Id: 123,
      Name: George
    },
    {
      Id: 456,
      Name: Lucas
    }
  ]
}
----

=== Reader Properties (for Excel)

When defining an input of type Excel, there are a few optional parameters you can add in the XML definition of your Mule project to customize how the data is parsed.

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`header` | bool | true |	defines if the Excel tables contain headers. When set to false, column names are used. (A, B, C, ...)
|`ignoreEmptyLine`	| bool | true | defines if empty lines are ignored
|`tableOffset` | string | A1 |	The position of the first cell of the tables
|===

////
TODO: UPDATE
* XML example:
+
[source,xml,linenums]
----
<dw:transform-message metadata:id="33a08359-5085-47d3-aa5f-c7dd98bb9c61"
  doc:name="Transform">
    <dw:input-payload
      <!-- Boolean that defines if the first line in the data contains headers -->
      <dw:reader-property name="header" value="true" />
      <!-- Boolean that defines if empty lines are ignored -->
      <dw:reader-property name="ignoreEmptyLine" value="false" />
      <!-- Defines that defines what cell to start reading from. In this case Column A is ignored, and all rows above 9 -->
      <dw:reader-property name="tableOffset" value="B9" />
    </dw:input-payload>
    <dw:set-payload>
        <![CDATA[
            %dw 2.0
            output application/java
            ---
            // Your transformation script goes here
        ]]>
    </dw:set-payload>
</dw:transform-message>
----

* Transform component
////
//TODO: IS THIS AVAILABLE IN STUDIO 7?
//image:dataweave-formats-excell-reader.png[]

=== Writer Properties (for Excel)

When defining an output of type Excel, there are a few optional parameters you can add to the output directive to customize how the data is parsed:

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`header` | bool | true |	defines if the Excel tables contain headers. When there are no headers, column names are used. (A, B, C, ...)
|`ignoreEmptyLine`	| bool | true | defines if empty lines are ignored
|`tableOffset` | string | A1 |	The position of the first cell of the tables
|===

All of these parameters are optional. An DataWeave output directive might for Excel might look like this:

.Example: output Directive
[source,DataWeave,linenums]
---------------------------------------------------------------------
output application/xlsx header=true
---------------------------------------------------------------------

=== Defining a Metadata Type (for Excel)

In the Transform component, you can define a Excel type through the following method:

* Through a graphical editor that allows you to set up each field manually.

//TODO: CHECK THIS:
image:dataweave-formats-excel-metadata.png[]

[[format_fixed_width]]
== Fixed Width

Mime Type: `application/flatfile`

// TODO: LINK <<Flat File>> here.
Fixed width types are technically considered a type of Flat File format, but when selecting this option the Transform component offers you settings that are better tailored to the needs of this format.

=== Reader Properties (for Fixed Width)

When defining an input of type Fixed Width, there are a few optional parameters you can add in the XML definition of your Mule project to customize how the data is parsed.

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`schemaPath`| string | | Location in your local disk of the schema file used to parse your input. The Schema must have an `.FFD` extension.
|`missingValues`| string | spaces a| How missing values are represented in the input data:

* `none`: treat all data as actual values
* `spaces`: interpret a field consisting of only spaces as a missing value
* `zeroes`: interpret numeric fields consisting of only '0' characters and character fields consisting of only spaces as missing values
* `nulls`: interpret a field consisting only of 0 bytes as a missing value

| `recordParsing` | string | strict a| expected separation between lines/records:

* `strict`: line break expected at exact end of each record
* `lenient`: line break used but records may be shorter or longer than schema specifies
* `noTerminator`: means records follow one another with no separation
|===

////
* XML example:
[source, xml, linenums]
----
<dw:input-payload mimeType="application/flatfile" >
  <dw:reader-property name="schemaPath" value="myschema.ffd"/>
  <dw:reader-property name="structureIdent" value="structure1"/>
</dw:input-payload>
----
+
* Transform component
////

//TODO: DOES THIS EXIST IN STUDIO 7
//image:dataweave-formats-6e5e4.png[]

=== Writer Properties (for Fixed Width)

When defining an output of type fixed width there are a few optional parameters you can add to the output directive to customize how the data is written:

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`schemaPath` |string | |Path where the schema file to be used is located
|`encoding` |string | UTF-8 | Output character encoding
|`missingValues` |string | spaces a| How to represent optional values missing from the supplied map:

* spaces: fill the field with spaces
* nulls: use 0 bytes

|`recordTerminator` | string | standard Java line termination for the system | Termination for every line/record. In Mule runtime versions 4.0.4 and older, this is only used as a separator when there are multiple records. Possible values: `lf, cr, crlf, none`. Values translate directly to character codes (`none` leaves no termination on each record).
|`trimValues` |boolean |`false` |Trim string values longer than field length by truncating trailing characters
|===

All of these parameters are optional. An DataWeave output directive might for Excel might look like this:

.Example: output Directive
[source,FixedWidth,linenums]
----
output application/flatfile schemaPath="src/main/resources/schemas/payment.ffd", encoding="UTF-8"
----

=== Defining a Metadata Type (for Fixed Width)

In the Transform component, you can define a Fixed Width type through the following methods:

* By providing a sample file.
* By pointing to a Flat File schema file.
* Through a graphical editor that allows you to set up each field manually.
+
image::dataweave-formats-27b3c.png[]
// TODO IS IMAGE OKAY?

[[format_flat_file]]
== Flat File

Mime Type: `application/flatfile`

=== Reader Properties (for Flat File)

When defining an input of type Flat File, there are a few optional parameters you can add in the XML definition of your Mule project to customize how the data is parsed.

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`schemaPath`| string | | Location in your local disk of the schema file used to parse your input. The Schema must have an `.ESL` extension.
|`structureIdent`|string |  | The schema file might define multiple different structures, this field selects which to use. In case the schema only defines one, you also need to explicitly select that one through this field.
|`missingValues`| string | spaces a| How missing values are represented in the input data:

* `none`: treat all data as actual values
* `spaces`: interpret a field consisting of only spaces as a missing value
* `zeroes`: interpret numeric fields consisting of only '0' characters and character fields consisting of only spaces as missing values
* `nulls`: interpret a field consisting only of 0 bytes as a missing value

| `recordParsing` | string | strict a| expected separation between lines/records:

* `strict`: line break expected at exact end of each record
* `lenient`: line break used but records may be shorter or longer than schema specifies
* `noTerminator`: means records follow one another with no separation
|===

////

* XML example:
[source, xml, linenums]
----
<dw:input-payload mimeType="application/flatfile" >
  <dw:reader-property name="schemaPath" value="myschema.esl"/>
  <dw:reader-property name="structureIdent" value="structure1"/>
</dw:input-payload>
----
////

Note that schemas with type `Binary` or `Packed` don't allow for line break detection, so setting `recordParsing` to `lenient` only allows long records to be handled, not short ones. These schemas also currently only work with certain single-byte character encodings (so not with UTF-8 or any multibyte format).

=== Writer Properties (for Flat File)

When defining an output of type flat file there are a few optional parameters you can add to the output directive to customize how the data is written:

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`schemaPath` |string | |Path where the schema file to be used is located
|`structureIdent` |string | |In case the schema file defines multiple formats, indicates which of them to use
|`encoding` |string | UTF-8 | Output character encoding
|`missingValues`| string | spaces a| How to represent optional values missing from the supplied map:

* `spaces`: fill the field with spaces
* `nulls`: use 0 bytes

|`recordTerminator`| string | standard Java line termination for the system | Termination for every line/record. In Mule runtime versions 4.0.4 and older, this is only used as a separator when there are multiple records. Possible values: `lf, cr, crlf, none`. Values translate directly to character codes (`none` leaves no termination on each record).
|`trimValues` |boolean |`false` |Trim string values longer than field length by truncating trailing characters
|===

.DataWeave Script that Output a Flat File
[source,DataWeave,linenums]
----
%dw 2.0
output application/flatfile schemaPath="src/main/resources/test-data/QBReqRsp.esl", structureIdent="QBResponse"
---
payload
----

=== Defining a Metadata Type (for Flat File)

In the Transform component, you can define a Flat File type by pointing to a schema file.

[[format_form_data]]
== Form Data (Multipart format)

Format: `multipart/form-data`

This format refers to an HTTP message with multiple parts separated by boundaries that can be named. These parts can include attachments. You can use a DataWeave script to extract and transform data from any of the parts by selecting the `parts` element.

For example, you might retrieve data from the HTTP header and an attachment.

.Sample HTTP Message with Extracted Form Data
image::postman-multipart.png[Multipart Example]

The example above uses the Postman app to create and post a part of a multi-part message, including an attachment. Then it uses a DataWeave script in a Mule app to extract the portion of the message shown in the Postman body.

To create this example:

. Use Postman to create the multi-part message:
.. Create two keys for the Body of an HTTP message to POST, such as `foo` and `bar`.
.. For `foo`, type in a text value such as `my value`.
.. For `bar`, load a file, such as a JSON file with content like this:
+
[source,JSON,linenums]
----
{
  "title": "Java 8 in Action",
  "author": "Mario Fusco",
  "year": 2014
}
----
+
.. Without sending the message yet, type a locally hosted URL to use for posting the message, for example: `localhost:8082/post`
+
image::postman-multipart-setup.png[Multipart Example]
+
. In Studio:
.. Add an HTTP Listener with these general settings:
+
* Host: `0.0.0.0`
* Port: `8082`
* Path: `/post`
.. Add a Transform component with this output script:
+
//payload.parts.bar.content.properties
+
.DataWeave Script that Transforms Multipart Input to JSON
[source,DataWeave,linenums]
----
%dw 2.0
output application/json
---
{ "multipart-example":
  {
    "content-type": payload.parts.bar.headers."Content-Type",
    "foo": payload.parts.foo.content,
    "bar": payload.parts.bar.content
  }
}
----
+
.. Save and Run the Mule app.
. In Postman, post your message to the HTTP Listener using this URL: `localhost:8082/post`.
+
Make sure to set Postman to POST. After sending the message, the body of the message should look like this in Postman's Pretty view:
+
[source,MultiPart,linenums]
----
{
  "multipart-example": [
    {
      "content-type": "application/json"
    },
    {
      "foo": "my value"
    },
    {
      "bar": {
        "title": "Java 8 in Action",
        "author": "Mario Fusco",
        "year": 2014
      }
    }
  ]
}
----

To see the entire structure of your multipart message, you can change (and save) the output script in the Transform component to something like this:

.DataWeave Script that Transforms Multipart Input to JSON
[source,DataWeave,linenums]
----
%dw 2.0
output application/json
---
payload.parts
----

If you post the same message to the HTTP Listener, the Postman body looks like this:

.Postman Pretty Print Output
[source,MultiPart,linenums]
----
{
  "foo": {
    "headers": {
      "Content-Disposition": {
        "name": "foo",
        "subtype": "form-data"
      }
    },
    "content": "my value"
  },
  "bar": {
    "headers": {
      "Content-Disposition": {
        "name": "bar",
        "filename": "sample_json.json",
        "subtype": "form-data"
      },
      "Content-Type": "application/json"
    },
    "content": {
      "title": "Java 8 in Action",
      "author": "Mario Fusco",
      "year": 2014
    }
  }
}
----

=== Reader Properties (for Form Data)

You can set a property for the writer to use when it outputs the data in the specified format.

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`boundary` | String | | Any string that matches a part of a form.
|===

Note that in the DataWeave `read` function, you can also pass the property as an optional parameter. The scope of the property is limited to the DataWeave script where you call the function.

=== Writer Properties (for Form Data)

The writer output form data using the DataWeave header directive:

.Example: output Directive
[source,DataWeave,linenums]
----
output multipart/form-data
----

In the output directive, you can also set a property for the writer to use when it outputs the data in the specified format.

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default |Description
|`boundary` | String | | Any string that matches a part of a form.
|===

For example, if a boundary is `file1`, then you can pass this:
.Example: output Directive
[source,DataWeave,linenums]
----
output multipart/form-data boundary=file1
----

Note that in the DataWeave `write` function, you can also pass the property as an optional parameter. The scope of the property is limited to the DataWeave script where you call the function.

[[format_java]]
== Java

Mime Type: `application/java`

This table shows the mapping between Java objects to DataWeave types.

[cols="3,1", options="header"]
|===
|Java Type
|DataWeave Type

|`Collections/Array/Iterator/Iterable`
| link:dataweave-types#array[Array]

|`String/CharSequence/Char/Enum/Class`
| link:dataweave-types#string[String]

|`int/Short/Long/BigInteger/Flat/Double/BigDecimal`
|link:dataweave-types#number[Number]

|`Calendar/XmlGregorainCalendar`
|link:dataweave-types#datetime[DateTime]

|`TimeZone`
|link:dataweave-types#timezone[TimeZone]

|`sql.Date/util.Date`
|link:dataweave-types#date[Date]

|`Bean/Map`
|link:dataweave-types#object[Object]

|`InputStream/Array[Byte]`
|link:dataweave-types#binary[Binary]

|`java.lang.Boolean`
|link:dataweave-types#boolean[Boolean]
|===

=== Custom Types (for Java)

There are a couple of custom Java types:

* `class`
* `Enum`

=== Metadata property `class` (for Java)

Java developers use the `class` metadata key as hint for what class needs to be created and sent as an input. If this is not explicitly defined, DataWeave tries to infer from the context or it assigns it the default values:

 * `java.util.HashMap` for objects
 * `java.util.ArrayList` for lists

[source,DataWeave, linenums]
-----------------------------------------------------------------------
%dw 2.0
type user = Object { class: "com.anypoint.df.pojo.User"}
output application/json
---
{
  name : "Mariano",
  age : 31
} as user

-----------------------------------------------------------------------

The code above defines the type of the required input as an instance of `com.anypoint.df.pojo.User`.

[[format_enum]]
=== Enum Custom Type (for Java)

In order to put an enum value in a `java.util.Map`, the DataWeave Java module defines a custom type called `Enum`. It allows you to specify that a given string should be handled as the name of a specified enum type. It should always be used with the class property with the java class name of the enum.

=== Defining a Metadata Type (for Java)

In the Transform component, you can define a Java type through the following method:

* By providing a sample object

[[format_json]]
== JSON

Mime Type: `application/json`

JSON data structures are mapped to DataWeave data structures because they share a lot of similarities.

=== Writer Properties (for JSON)

When defining an output of type JSON, there are a few optional parameters you can add to the output directive to customize how the data is parsed:

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default |Description
|`indent`| boolean | true | Defines if the JSON code will be indented for better readability, or if it will be compressed into a single line
|`encoding`| string | UTF-8 |The character set to be used for the output
|`bufferSize`| number | 153600 | The size of the buffer writer
|`inlineCloseOn` | string | | When the writer should use inline close tag. Possible values = empty/none
|`skipNullOn`| string | | Possible values = `elements`/`attributes`/`everywhere`. See <<Skip Null On>>
|`duplicateKeyAsArray`| boolean | false | JSON language doesn't allow duplicate keys with one same parent, this usually raises an exception. If set to true, the output contains a single key that points to an array containing all the values assigned to it.
|===

.Example: output Directive
[source,DataWeave,linenums]
---------------------------------------------------------------------
output application/json indent=false, skipNullOn="arrays"
---------------------------------------------------------------------

==== Skip Null On (for JSON)

You can specify whether this generates an outbound message that contains fields with "null" values, or if these fields are ignored entirely. This can be set through an attribute in the output directive named `skipNullOn`, which can be set to three different values: `elements`, `attributes`, or `everywhere`.

When set to:
* `elements`: A key:value pair with a null value is ignored.
* `attributes`: An XML attribute with a null value is skipped.
* `everywhere`: Apply this rule to both elements and attributes.

=== Defining a Metadata Type (for JSON)

In the Transform component, you can define a JSON type through the following methods:

* By providing a sample file
* By pointing to a schema file

[[format_xml]]
== XML

Mime Type: `application/xml`

The XML data structure is mapped to DataWeave objects that can contain other objects as values to their keys. Repeated keys are supported. Example:

.Input
[source,xml, linenums]
----
<users>
  <company>MuleSoft</company>
  <user name="Leandro" lastName="Shokida"/>
  <user name="Mariano" lastName="Achaval"/>
</users>
----

.DataWeave Script
[source,DataWeave,linenums]
----
{
  users: {
    company: "MuleSoft",
    user @(name: "Leandro",lastName: "Shokida"): "",
    user @(name: "Mariano",lastName: "Achaval"): ""
  }
}
----

=== Reader Properties (for XML)

When defining an input of type XML, there are a few optional parameters you can add in the XML definition of your Mule project to customize how the data is parsed.

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default |Description
|`optimizeFor`| string | speed | specifies the strategy to be used by the reader. Posible values = memory/speed
|`nullValueOn`|string | 'empty' |If a tag with empty or blank text should be read as null.
|`indexedReader`|boolean | true | Picks which reader modality to use. The indexed reader is faster but uses up a greater amount of memory, whilst the unindexed reader is slower but uses up less memory
|`maxEntityCount`|integer | 1 | Limits the number of times that an entity can be referenced within the XML code. This is included to guard against link:https://en.wikipedia.org/wiki/Billion_laughs[denial of service attacks].
|`externalEntities`|boolean | false | Defines if references to entities that are defined in a file outside the XML are accepted as valid. It's recommended to avoid these for link:https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing[security reasons] as well.
|===


////
TODO: UPDATE

* XML example:
+
[source,xml,linenums]
----
<dw:transform-message metadata:id="33a08359-5085-47d3-aa5f-c7dd98bb9c61"
  doc:name="Transform">
    <dw:input-payload
      <!-- specifies the strategy to be used by the reader -->
      <dw:reader-property name="optimizeFor" value="speed" />
      <!-- If a tag with empty or blank text should be read as null. -->
      <dw:reader-property name="nullValueOn" value="empty" />
    </dw:input-payload>
    <dw:set-payload>
      <![CDATA[
        %dw 2.0
        output application/xml
        ---
        // Your transformation script goes here
      ]]>
    </dw:set-payload>
</dw:transform-message>
----
+
* Transform component
+
////

// TODO: is this available in studio 7?
//image:dataweave-formats-6e5e4.png[]

=== Writer Properties (for XML)

When defining an output of type XML, there are a few optional parameters you can add to the output directive to customize how the data is parsed:

[cols="2,1,1,2", options="header"]
|===
|Parameter |Type |Default|Description
|`indent`| boolean | true | Defines if the XML code will be indented for better readability, or if it will be compressed into a single line
| `inlineCloseOn` | string | `never` | Defines wether an empty XML child element appears as single self-closing tag or with an opening and closing tag. The value `empty` sets it to output self-closing tags.
|`encoding`|string | UTF-8 |The character set to be used for the output
|`bufferSize`| number | 153600 | The size of the buffer writer
|`inlineCloseOn` | string | | When the writer should use inline close tag. Possible values = `empty`/`none`
|`skipNullOn`| string | | Possible values = `elements`/`attributes`/`everywhere`. See <<Skip Null On>>
|`writeDeclaration`| boolean | true | Defines if the XML declaration will be included in the first line
|===

.Example: output Directive
[source,DataWeave,linenums]
---------------------------------------------------------------------
output application/xml indent=false, skipNullOn="attributes"
---------------------------------------------------------------------

The `inlineCloseOn` parameter defines whether the output is structured like this (the default):

[source,xml,linenums]
----
<someXml>
  <parentElement>
    <emptyElement1></emptyElement1>
    <emptyElement2></emptyElement2>
    <emptyElement3></emptyElement3>
  </parentElement>
</someXml>
----

It can also be structured like this (set with a value of `empty`):

[source,xml,linenums]
----
<payload>
  <someXml>
    <parentElement>
      <emptyElement1/>
      <emptyElement2/>
      <emptyElement3/>
    </parentElement>
  </someXml>
</payload>
----

==== Skip Null On (for XML)

You can specify whether your transform generates an outbound message that contains fields with "null" values, or if these fields are ignored entirely. This can be set through an attribute in the output directive named `skipNullOn`, which can be set to three different values: `elements`, `attributes`, or `everywhere`.

When set to:

* `elements`: A key:value pair with a null value is ignored.
* `attributes`: An XML attribute with a null value is skipped.
* `everywhere`: Apply this rule to both elements and attributes.

=== Defining a Metadata Type (for XML)

In the Transform component, you can define a XML type through the following methods:

* By providing a sample file
* By pointing to a schema file

[[format_cdata]]
=== CData Custom Type (for XML)

Mime Type: `application/xml`

`CData` is a custom data type for XML that is used to identify a CDATA XML block. It can tell the writer to wrap the content inside CDATA or to check if the input string arrives inside a CDATA block. `CData` inherits from the type `String`.

.DataWeave Script
[source,DataWeave, linenums]
----------------------------------------------------------------------
%dw 2.0
output application/xml
---
{
  users:
  {
    user : "Mariano" as CData,
    age : 31 as CData
  }
}
----------------------------------------------------------------------

.Output
[source,xml,linenums]
----------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<users>
  <user><![CDATA[Mariano]]></user>
  <age><![CDATA[31]]></age>
</users>
----------------------------------------------------------------------

[[format_url_encoded]]
== URL Encoding

Mime Type: `application/x-www-form-urlencoded`

A URL encoded string is mapped to a DataWeave object.

.Input
[source, code, linenums]
----
key=value&key+1=value%40&key=value+here&key+2%25
----

.DataWeave Script
[source,DataWeave,linenums]
----
{
  "key" : ["value", "value here"],
  "key 1": "value@",
  "key 2%": null
}
----

Note that there are no reader properties for URL encoded data.

=== Writer (for URL encoded data)

The writer output form data using the DatawWave header directive:

.Example: output Directive
[source,DataWeave,linenums]
----
output application/x-www-form-urlencoded
----

In the output directive, you can also set a property for the writer to use when it outputs the data in the specified format.

// TODO: ASK SHOKI ABOUT KB VS BYTES
[cols="2,1,2", options="header"]
|===
|Parameter | Default |Description
|`encoding` | UTF-8 | Specifies the encoding to use.
|`bufferSize` | 192 kb | Specifies a number of bytes to use for the buffer.
|===

.Example: output Directive
[source,DataWeave,linenums]
----
output application/x-www-form-urlencoded encoding="UTF-8", bufferSize="500"
----

Note that in the DataWeave `write` function, you can also pass the property as an optional parameter. The scope of the property is limited to the DataWeave script where you call the function.

== See Also

* link:/anypoint-studio/v/7/transform-message-component-concept-studio[About the Transform Message Component]
* link:dataweave-flat-file-schemas[Flat File Schemas]

// sme: Ana, author: sduke?
= Introduction to Mule 4: Error Handlers

In Mule 4, error handling in handled by Mule error types. Though all the Java `Throwable` errors and exceptions are available, Mule 4 introduces a formal Error concept that's easier to use. Now, each component declares the type of errors it can throw, so you can easily identify the most common potential errors at design time.

[NOTE]
Compared to Mule 3 which had Excpetion handlers, in Mule 4 exception handling is no longer limited to a Java exception handling process that requires you to check the source code or force the error to understand what happened. 



== Mule Errors
Execution failures are represented by Mule errors with the following components:

* A description of the problem
* A type, used to characterize the problem
* A cause, the underlying Java `Throwable` that resulted in the failure
* An optional error message, which is used to include a proper Mule Message regarding the problem

For example, when an HTTP request fails with a 401 status code, a Mule error provides the following information:

-----
Description: HTTP GET on resource ‘http://localhost:36682/testPath’ failed: unauthorized (401)
Type: HTTP:UNAUTHORIZED
Cause: a ResponseValidatorTypedException instance
Error Message:  { "message" : "Could not authorize the user." }
-----

== Error Types
In the example above, the error type is HTTP:UNAUTHORIZED, not simply UNAUTHORIZED. Error types consist of both a namespace and an identifier, allowing you to differentiate categories of error types according to different conceptual domains (for example, HTTP:NOT_FOUND and FILE:NOT_FOUND). While connectors define their own namespace, core runtime errors have an implicit one, so  MULE:EXPRESSION and EXPRESSION are interpreted as the same error type.

Another important characteristic of error types is that they are hierarchical. So a particular error type might have a parent, or might be extended to a more specific child error type. For example, HTTP:UNAUTHORIZED extends the parent MULE:CLIENT_SECURITY error type, which, in turn, extends the MULE:SECURITY error type. This establishes error types as specifications of more global ones. For example an HTTP unauthorized error is a type of client security error, where the client security error represents a more broad grouping of security issues.

These hierarchies allow routing to be more general, since, for example, a handler for MULE:SECURITY will catch HTTP unauthorized errors as well as OAuth errors. Like Java excpetion handling hierarchies, this gives developers the flexibility to decide at what granularity they want to handle errors. 

Below you can see what the core runtime hierarchy looks like:

image::error-hierarchy.png[Error Hierarchy]

All errors are either general or CRITICAL, the latter being so severe that they cannot be handled. At the top of the general hierarchy is ANY, which allows matching all types under it.

It’s important to note the UNKNOWN type, which is used when no clear reason for the failure is found. This error can only be handled through the ANY type to allow specifying the unclear errors in the future, without changing the existing app's behavior.

When it comes to connectors, each connector defines its error type hierarchy considering the core runtime one, though CONNECTIVITY and RETRY_EXHAUSTED types are always present because they are common to all connectors.

== Error Handlers

Mule 4 has redesigned error handling by introducing the `error-handler` component, which can contain any number of internal handlers and can route an error to the first one matching it. Such handlers are `on-error-continue` and `on-error-propagate`, which both support matching through an error type (or group of error types) or through an expression (for advanced use cases). These are quite similar to the Mule 3 choice (`choice-exception-strategy`), catch (`catch-exception-strategy`), and rollback (`rollback-exception-strategy`) exceptions strategies However, they are much simpler and more consistent.

If an error is raised within a flow in Mule 4, its error handler will be executed and the error will be routed to the first matching handler. At this point, the error is available for inspection, so the handlers can execute and act accordingly:

* An `on-error-continue` will execute and use the result of the execution, as the result of its owner (as if the owner had actually completed the execution successfully). Any transactions at this point would be committed as well.
* An `on-error-propagate` will roll back any transactions, execute, and use that result to re-throw the existing error, meaning its owner will be considered as “failing.”

Consider the following application where an HTTP listener triggers a Flow reference to another flow that performs an HTTP request. If everything goes right when a message is received (1 below), the reference is triggered (2), and the request performed (3), which results in a successful response (4).

image::error-handling-example-1.png[Error Handling Example 1]

If the HTTP request fails with a not found error (see 3 above) because of the error handler setup of `inner-flow`, then the error will be propagated (4), and the flow reference will fail (2). However, because `primary-flow` is handling that with an `on-error-continue`, this will execute (5), and a successful response will be returned (6).

image::error-handling-example-2.png[Error Handling Example 1]

If the request fails with an unauthorized error instead (3), then  `inner-flow` will handle it with an `on-error-continue` by retrieving static content from a file (4). Then the Flow reference will be successful as well (2), and a successful response will be returned (5).

image::error-handling-example-3.png[Error Handling Example 3]

But what if another error occurred in the HTTP request? Although there are only handlers for NOT_FOUND and UNAUTHORIZED errors in the flow, errors are still propagated by default. This means that if no handler matches the error that is raised, then it will be re-thrown. For example, if the request fails with a method not allowed error (3), then it will be propagated, causing the flow reference to fail (2), and that propagation will result in a failure response (4).

image::error-handling-example-4.png[Error Handling Example 4]

The scenario above can be avoided by making the last handler match ANY, instead of just HTTP:UNAUTHORIZED. Notice how, below, all the possible errors of an HTTP request are suggested:

image::error-handling-any.png[Error Handling Any]

You can also match errors using an expression. For example, since the Mule Error is available during error handling, we can use it to match all errors with the HTTP namespace:

image::error-handling-expression.png[Error Handling Expression]

== Try Scope
For the most part, Mule 3 only allows error handling at the flow level, forcing you to extract logic to a flow in order to address errors. In Mule 4, we’ve introduced a Try scope that you can use within a flow to do error handling of just inner components. The scope also supports transactions, which replaces the old Transactional scope.

image::error-handling-try.png[Try Scope]

The error handler behaves as we have explained earlier. In the example above, any database connection errors are propagated, causing the `try` to fail and the flow’s error handler to execute. In this case, any other errors will be handled, and the Try scope will be considered successful which, in turn, means that the next processor in the flow, an HTTP request, will continue executing.

== Error Mapping
Components that can throw various error types. Sometimes you might want to rename the standard error types to a type that is more specific to the context of your flows and applications. In this case you can map various error types to a new custom error type. 

Surrounding a particular component in Try scope is useful and lets you isolate the error handling logic, but if you have several equal components and want to distinguish the errors of each one, using a Try scope around each component can clutter your app. Instead, you can add custom error mappings to each component, meaning that all or certain kind of errors streaming from the component will be mapped to another error of your choosing. Then you can bundle these components together into a common Try scope, or you can let the flow's error handler process all possible errors in the flow. 

For example, if you are aggregating results from 2 APIs using an HTTP request component for each, you might want to distinguish between the errors of API 1 and API 2, since by default, their errors will be the same, but handle all these errors in a common Try scope, or even in a global error handler. 

By mapping errors from the first request to a custom API_1 error and errors in the second request to API_2, you can route those errors to different handlers, or filter the error types inside a common error handler. The next example maps HTTP:INTERNAL_SERVER_ERROR  so that different handling policies can be applied if the APIs go down (propagating the error in the first API and handling it in the second API).

image::error-handling-mappings.png[Error Handling Mappings]

Error mappings are available in the Error Mappings tab of a component. You can map one or more *source* error types (error types defined by  MuleSoft) to a new *target* error type. The target error type has a custom namespace and type. You can map several error types to the same custom error type, to combine error message types together. Here is an example of mapping two different HTTP Requestor error types to a custom error type named `APP:CUSTOM_ERROR`

-----
			<http:request method="GET" doc:name="Request" doc:id="93dd48fb-143f-4aa0-8b12-1aaeb7ddaaca" config-ref="HTTP_Request_configuration" path="/delta?wsdl">
				<error-mapping sourceType="HTTP:CONNECTIVITY" targetType="APP:CUSTOM_ERROR" />
				<error-mapping sourceType="HTTP:TOO_MANY_REQUESTS" targetType="APP:CUSTOM_ERROR" />
			</http:request>
 -----

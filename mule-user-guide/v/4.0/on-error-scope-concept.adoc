= About On-Error Scopes

Mule 4 introduces the error-handler component. +
The error-handler component can contain any number of internal handlers known as on-error scopes. The on-error scope defines the type or group of types of error it expects. So when an error occurs, the error-handler component routes the Mule error to the first on-error scope that matches the error type. +
At this point, the error is available for inspection, so the on-error scopes can execute and act accordingly.

Mule supports two types of On Error Scopes. Both allow conducting matching through an error type (or group of) or through an expression (for advanced use cases). Each scope defines a different behavior for when an error occurs:

[%header%autowidth.spread,cols='a,a']
|===
|On Error Scope |Description
// | Default Error Handling
// | Defined and implicitly applied by default to handle all messaging errors that are not handled by any On Error scopes. This is equivalent to an On Error Propagate with no child components for handling errors.
//
// | On Error Continue
// | If an error occurs within the Try scope, any other components in the scope are skipped, and execution continues immediately after the scope ends. +
// If a transaction is being handled, it’s committed.
//
// image:error-handling-f7bf0.png[]

// COMBAK: On-Error retry not availabel for Beta
// | On Error Retry
// | If an error occurs within the Try scope, the entire scope is attempted again. +
// There can only be one On Error Retry scope in each Error Handler.

| On Error Propagate
| Propagates to the next level up and the execution of the entire flow breaks. As an exception, if the failing Try scope is nested within another Try scope with an On Error Continue, execution is continued outside the parent scope. +
If a transaction is being handled, it’s rolled back.

image:error-handling-e77ec.png[]

| On Error Continue
| Executes and uses the result of the execution, as the result of its owner. As if the owner had actually completed the execution successfully. +
If a transaction is being handled, it would be committed as well.
|===

Each On Error Scope can be set up to be triggered by a different set of error types. Both in Studio and Design Center, you can pick from a list of errors that could be raised by the components you placed inside the scope.

You can also set up a path to be triggered by type *ANY*, referring to all error types that aren't used by other paths. Note that conditions are evaluated in order, so for other paths to be evaluated, the *ANY* path must always be the last.

As an alternative to mapping a path to a set of error types, you can map it to a freely defined condition. For example, you can map a path to a condition by setting the When field to:

`#[ error.cause.message contains "fatal" ]`

Each flow can contain only one error handler, however this error handler can contain as many On Error scopes as you see necessary.

== Custom Error Mapping


In each operation component in your flow, you can map standard error types to a custom error type. You can use these custom error types to differentiate exactly where an error occurred in your flow. For example, if your flow has two HTTP Request connectors that reach out to different REST services, a connectivity error on either produces the same error message. By setting different custom error types for each, you can tell which of them failed from the error message.


== See Also

* link:/mule-user-guide/v/4.0/mule-error-concept[About the Mule Error]
* link:/mule-user-guide/v/4.0/try-scope-concept[About Try Scope]

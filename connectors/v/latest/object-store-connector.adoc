= Object Store Connector
:keywords: object store, object, store, connector

*Reference:* link:object-store-connector-reference[Object Store Connector Reference]

An Object Store is a Mule component that allows for simple key-value storage. Although it can serve a wide variety of use cases, it is mainly design for:

* Storing synchronization information, such as watermarks.
* Storing temporal information such as access tokens.
* Storing user information.

Additionally, Mule Runtime uses Object Stores to support some of its own components, for example:

* The cache module uses an Object Store to maintain all of the cached data.
* The OAuth module (and every OAuth enabled connector) uses Object Stores to store the access and refresh tokens.
* The `<until-successful/>` component uses an Object Store to store all the messages it has to retry. So, if Mule crashes, those messages are not lost and can continue processing when it recovers.


== Object Store Limitations

Object Stores are not a universal solution for data storage. They do not replace a database, and they are not suitable for every use case. Most importantly, they do not support transactional access or modification. For use cases in which link:https://en.wikipedia.org/wiki/ACID[ACID] semantics are needed, or cases in which you expect the same key to be updated in parallel, consider some other solution.

== Scopes of Object Store

By default, each Mule application has a default object store, which is persistent. This default object store is always available to the Mule application without any configuration. Flows can persist and share data using this default object store. Moreover, when the Mule application is deployed into CloudHub workers using Anypoint Platform Runtime Manager, the contents of the Mule application's default object store are visible in Runtime Manager in the Mule application's Application Data tab.

Note: To specify the default object store, do not select or create an Object Store reference. In the XML element for each object store component, be sure there is no *objectStore* attribute specified. Any time you include the objectStore attribute, the default object store will not be used.

However, you can also define additional object stores. Custom object stores have a variety of custom configuration parameters and option which can differ from the default object store's behavior, including specifying if the object store should be persistent (Where the object store data survives the Mule runtime crashing), or transient (where data does not survive the Mule runtime crashing).  Some common reasons to define additional custom object stores can be:

* You want to partition your information by storing them in different stores
* You want to use advanced ObjectStore features such as:
** Transient/Persistent storage
** Specify a time to live (TTL)
** Specify a max capacity
* You want to keep different components from sharing state by feeding them with different stores
* You want different components to share information by feeding them with the same store

You can define an object store globally in the application so it can be referenced by name and shared between multiple components, or you can create a object store which is “private” to a particular component.

Note: The only object store displayed in the Runtime Manager Application Data tab is the default persistent object store.

=== Use a Global ObjectStore when:

* Need to share state across components: Because the store can be reference by name, other components could also use it. Suppose you have a second instance of the salesforce connector, only that configured slightly different. You can use this other instance using the same tokens, avoiding the need to authenticate again.
* Need to share state across Cluster Nodes: When you’re using Mule in cluster mode, you may want to have information which is available to every node in the cluster. Global ObjectStores are ideal for that.
* Need to use the information in your application’s logic: The ObjectStore connector is not only capable of defining that store, it can also manipulate it. All of the operations we first described operate over the default object store by default. But they also accept referencing a global object store, so that you can act on them instead of the default one. For example, suppose you want to have an audit flow which verifies if certain users are currently authorized. You could do something like this:

`<os:contains id="#[userId]" objectStore="tokensStore" />`

=== Use a Private ObjectStore to:

* Share state can either be a feature or a security risk.
* Be able to manipulate the store from the connector can either be a feature, or something error prone. Some developer could accidentally end up doing a bad use of the clear operation and delete all the authorization data.

See also

* link:object-store-to-store-and-retrieve[To Store and Retrieve information from an Object Store]
* link:object-store-to-define-a-new-os[To Define a new Object Store]
* link:object-store-to-watermark[Example: Watermark]

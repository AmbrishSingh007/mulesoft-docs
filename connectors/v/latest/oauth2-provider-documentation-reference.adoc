:toc:               left
:toc-title:         OAuth2 Provider Module
:toclevels:         2
:last-update-label!:
:docinfo:
:source-highlighter: coderay
:icons: font

[[oauth2-provider-reference]]
== OAuth2 Provider Module Documentation Reference

The OAuth2 Provider Module allows a Mule Application to be configured as an Authentication Manager in an OAuth2 Dance.
With this role, the application will be able to grant authenticate previously registered clients, grant tokens and validate them or register and delete clients, all during the execution of a flow.

Note: If the app should behave as the Client in the OAuth2 Dance, then the Oauth-module should be used.

== Configurations

[[general-configuration]]
=== General Configuration

[source, xml]
----
 <oauth2-provider:config name="OAuth2Provider"
                         listenerConfig="httpListenerConfig"
                         resourceOwnerSecurityProvider="resourceOwnerSecurityProvider"
                         clientSecurityProvider="clientSecurityProvider"
                         supportedGrantTypes="AUTHORIZATION_CODE"
                         scopes="USER,ADMIN"
                         defaultScopes="USER"
                         clientStore="clientObjectStore">
         <oauth2-provider:client-validation-rate-limiter>
            <oauth2-provider:period-rate-limiter duration="600"
                                                 durationTimeUnit="SECONDS"
                                                 maximumFailureCount="5"/>
         </oauth2-provider:client-validation-rate-limiter>
         <oauth2-provider:token-config path="/token"
                                       tokenStore="tokenObjectStore"
                                       tokenTtl="86400"
                                       tokenTtlTimeUnit="SECONDS">
            <oauth2-provider:refresh-token-strategy>
                <oauth2-single-refresh-token objectStore="refreshTokenObjectStore"/>
            </oauth2-provider:refresh-token-strategy>
         </oauth2-provider:token-config>
         <oauth2-provider:authorization-config loginPage="static/auth.html"
                                               path="/authorize"
                                               objectStore="authorizationCodeObjectStore"/>
         <oauth2-provider:clients>
             <oauth2-provider:client clientId="clientId1"
                                     clientName="someClient"
                                     secret="clientSecret1"
                                     principal="clusr"
                                     description="Some test client"
                                     type="CONFIDENTIAL">
                 <oauth2-provider:client-redirect-uris>
                     <oauth2-provider:client-redirect-uri value="http://fake/redirect"/>
                 </oauth2-provider:client-redirect-uris>
                 <oauth2-provider:client-authorized-grant-types>
                     <oauth2-provider:client-authorized-grant-type value="AUTHORIZATION_CODE"/>
                 </oauth2-provider:client-authorized-grant-types>
                 <oauth2-provider:client-scopes>
                     <oauth2-provider:client-scope value="USER"/>
                 </oauth2-provider:client-scopes>
             </oauth2-provider:client>
         </oauth2-provider:clients>
     </oauth2-provider:config>
----

==== Parameters
[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]
|======================
| Name | Type | Description | Default Value | Required
| Name | String | The name for the OAuth2 Provider | {nbsp}| *x*{nbsp}
| Provider Name | String | The name supplied to the customers of the API. This is used as some responses of the OAuth2 API | Same as Name | {nbsp}
| Listener Config | String | The name of an Http Listener Config to reference. It'll handle the token and authorization endpoints | {nbsp} | *x*{nbsp}
| Resource Owner Security Provider | String | A reference to the Security Provider used to authenticate resource owners. Not needed if only CLIENT_CREDENTIALS grant type is used | {nbsp} | {nbsp}
| Client Security Provider | String | A reference to the Security Provider used to authenticate clients. Not needed if only public clients or private clients with secrets are used | {nbsp} | {nbsp}
| Client Store | Object Store | A reference to a globally defined object store or a definition of a private object store. It's used to store the registered clients information | Object Store created by the Object Store Manager | {nbsp}
| Grant Types | String | A comma separated list of supported grant types. Possible values are: AUTHORIZATION_CODE,IMPLICIT,RESOURCE_OWNER_PASSWORD_CREDENTIALS or CLIENT_CREDENTIALS | AUTHORIZATION_CODE | {nbsp}
| Scopes | String | A comma separated list of supported scopes | {nbsp} | {nbsp}
| Default Scopes | String | A comma separated list of scopes to apply to clients if they don't define their own | {nbsp} | {nbsp}
| Client Validation Rate Limiter | Client Validation Rate Limiter | Rate limiter to control access to validate client operations. It will control that failures calls within a certain period do not exceed a maximum count. After that number of failures is reached, the requests will be rejected | Period rate limiter with duration = 600 secs and maximum failure count = 5 | {nbsp}
| Authorization Config | Authorization Config | Configuration related to authorization code handling | {nbsp} | {nbsp}
| Token Config | Token Config | Configuration related to token handling | {nbsp} | {nbsp}
|======================


=== Security Providers

As seen in the <<general-configuration>>, two security providers should be defined in the application to be later referenced by the OAuth2 Configuration element.

One way of doing this is by using the Spring Framework, defining both security providers and then using the link:spring-module.adoc[Spring Module] to add them to the Mule Security Manager as so:

[source, xml]
----
<spring:security-manager>
    <spring:delegate-security-provider name="clientSecurityProvider"
                                       delegate-ref="clientAuthenticationManager"/>
    <spring:delegate-security-provider name="resourceOwnerSecurityProvider"
                                       delegate-ref="resourceOwnerAuthenticationManager"/>
</spring:security-manager>
----

=== Client Validation Rate Limiter

Allows to configure a mechanism to prevent the continuous client validation when it's using invalid credentials.

As for this moment, only a  `period-rate-limiter` is implemented that handles rate limiting based on a time period.

==== Parameters
[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]
|======================
| Name | Type | Description | Default Value | Required
| Duration | Number | The time to wait before resetting the rate limiter. That means that during time intervals of _duration_ lenth, every time a client validation fails, it will be added to the failure count | 600 | {nbsp}
| Duration Time Unit | Time Unit | The time unit for the duration attribute | SECONDS | {nbsp}
| Maximum Failure Count | Number | Maximum number of failures allowed within the period before preemptively rejecting requests | {nbsp} | {nbsp}
|======================


=== Authorization Code Configuration

Configuration related to authorization code handling and the authorization endpoint.

==== Parameters
[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]
|======================
| Name | Type | Description | Default Value | Required
| Login Page | String | Relative file path to the web page for the resource owner to provide it's credentials  | www-static/auth.html | {nbsp}
| Path | String | The Url relative path to the authorization endpoint in the HTTP server for listening to authorization requests | /authorize | {nbsp}
| Authorization Code Store | Object Store | A reference to a globally defined object store or a definition of a private object store. It's used to store generated authorization codes | A persistent object store created from the ObjectStoreManager with an entry TTL of 600 SECONDS | {nbsp}
|======================

=== Token Configuration

Configuration related to token handling and the token endpoint.

==== Parameters
[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]
|======================
| Name | Type | Description | Default Value | Required
| Path | String | The Url relative path to the token endpoint in the HTTP server for listening to token requests | /token | {nbsp}
| Token Store | Object Store | A reference to a globally defined object store or a definition of a private object store. It's used to store generated tokens | A persistent object store with an entry TTL of 86400 SECONDS | {nbsp}
| Token Ttl | Number | The time for a granted token to be considered valid after granting it. The value should be the same as the entryTtl of the token store if a custom one is configured | 86400 | {nbsp}
| Token Ttl Time Unit | Time Unit | The Time Unit to use for the token TTL. It should be the same as the entryTtlTimeUnit of the token store if a custom one was configured | SECONDS | {nbsp}
| Refresh Token Strategy | Refresh Token Strategy | Configures how refresh tokens should be handled in every refresh token request | No Refresh Token | {nbsp}
|======================

==== Refresh Token Strategy

The refresh token strategy configures how refresh tokens are granted and how they should be handled every time a refresh token request is executed.

===== No Refresh Token

There will be no refresh token granted with every access token. As a consequence,  when a refresh token request comes, it will always be rejected.

===== Single Refresh Token

For every new access token that is granted, a single refresh token will be associated with it. That same refresh token should be used every time the access token is refreshed.

====== Parameters
[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]
|======================
| Name | Type | Description | Default Value | Required
| Object Store | Object Store | A reference to a globally defined object store or a definition of a private object store. It's used to store generated refresh tokens | A persistent object store created from the ObjectStoreManager with an entry TTL of 86400 SECONDS | {nbsp}
|======================

===== Multiple Refresh Token

A new refresh token will be generated every time a refresh token request is executed. After that, the previous refresh token will be invalidated.

====== Parameters
[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]
|======================
| Name | Type | Description | Default Value | Required
| Object Store | Object Store | A reference to a globally defined object store or a definition of a private object store. It's used to store generated refresh tokens | A persistent object store created from the ObjectStoreManager with an entry TTL of 86400 SECONDS | {nbsp}
|======================

== Operations

[[validate-token]]
=== Validate Token
[source, xml]
----
<aggregators:size-based-aggregator  name="sizeBasedAggregator"
                                    maxSize="10"
                                    timeout="60"
                                    timeoutUnit="MINUTES"
                                    objectStore="exampleObjectStore">
    <aggregators:content>
        #[message]
    </aggregators:content>
    <aggregators:incremental-aggregation>
        ...
    </aggregators:incremental-aggregation>
    <aggregatos:aggregation-complete>
        ...
    </aggregators:aggregation-complete>
</aggregators:size-based-aggregator>`
----

Aggregates elements until a pre-defined size is reached, executing the routes and listeners.


==== Parameters
[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]
|======================
| Name | Type | Description | Default Value | Required
| Name | String | The name of the aggregator. It can later be used to be referenced by an aggregator listener | {nbsp}| *x*{nbsp}
| Content | Expression | The expression that defines what is going te be aggregated. The result of the evaluation will be the value stored in the aggregation | #[message] | {nbsp}
| Max Size | Number | The total number of elements to be aggregated before considering the aggregation complete | {nbsp} | *x*{nbsp}
| Timeout | Number |  A max time to wait for the aggregation to complete. If the timeout is reached before the total number of elements is equal to max size, the aggregation will be considered complete regarding that. A value of 0 is not supported since the group would be timing out constantly | -1(UNLIMITED) | {nbsp}
| Timeout unit | Time Unit | The time unit in which to measure the timeout |  SECONDS | {nbsp}
| Object Store | Object Store |  Either a name to reference a global object store or a definition of a private object store where the aggregated elements will be stored |  Default Object Store partition | {nbsp}
| Aggregation Complete Route | Route | Components chain that will be executed once the aggregation is complete | {nbsp} | *x*{nbsp}
| Incremental Aggregation Route | Route | Components chain that will be executed for every new element that is aggregated. The payload will be the list of aggregated elements until this moment | {nbsp} | {nbsp}
|======================


==== Raises
* AGGREGATORS:AGGREGATOR_CONFIG
+
{nbsp} Whenever maxSize or timeout have invalid values(e.g: maxSize < 0).


[[revoke-token]]
=== Revoke Token
[source, xml]
----
<aggregators:time-based-aggregator  name="timeBasedAggregator"
                                    period="60"
                                    periodUnit="MINUTES"
                                    maxSize="10"
                                    objectStore="exampleObjectStore">
    <aggregators:content>
        #[message]
    </aggregators:content>
    <aggregators:incremental-aggregation>
        ...
    </aggregators:incremental-aggregation>
</aggregators:time-based-aggregator>`
----


Aggregates elements until a time period is completed, executing the routes and listeners.


==== Parameters
[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]
|======================
| Name | Type | Description | Default Value | Required
| Name | String | The name of the aggregator. It can later be used to be referenced by an aggregator listener | {nbsp}| *x*{nbsp}
| Content | Expression | The expression that defines what is going te be aggregated. The result of the evaluation will be the value stored in the aggregation | #[message] | {nbsp}
| Period | Number |  A time period to wait until considering the aggregation complete| {nbsp} | *x*{nbsp}
| Period unit | Time Unit | The time unit in which to measure the time period |  SECONDS | {nbsp}
| Max Size | Number | The total number of elements to be aggregated before considering the aggregation complete | -1(UNLIMITED) | {nbsp}
| Object Store | Object Store |  Either a name to reference a global object store or a definition of a private object store where the aggregated elements will be stored |  Default Object Store partition | {nbsp}
| Incremental Aggregation Route | Route | Components chain that will be executed for every new element that is aggregated. The payload will be the list of aggregated elements until this moment | {nbsp} | {nbsp}
|======================

==== Raises
* AGGREGATORS:AGGREGATOR_CONFIG
+
{nbsp} Whenever period or maxSize have invalid values(e.g: Period = 0)

[[create-client]]
=== Create Client
[source, xml]
----
<aggregators:group-based-aggregator name="groupBasedAggregator"
                                    groupId="#[correlationId]"
                                    groupSize="#[itemSequenceInfo.sequenceSize]"
                                    evictionTime="180"
                                    evictionTimeUnit="SECONDS"
                                    timeout="60"
                                    timeoutUnit="MINUTES"
                                    objectStore="exampleObjectStore">
    <aggregators:content>
        #[message]
    </aggregators:content>
    <aggregators:incremental-aggregation>
        ...
    </aggregators:incremental-aggregation>
    <aggregatos:aggregation-complete>
        ...
    </aggregators:aggregation-complete>
</aggregators:group-based-aggregator>`
----


Aggregates elements in different groups according to a group Id.

Every time a new event arrives to the aggregator, the id of the element will be resolved. If a group with that id already exists in the aggregator, the value will be added to that group. Otherwise, a new group with that id will be created and the received element will be the first element in that group aggregation.

Some new important concepts appear with the group based aggregator :

* _Group timeout_ is when a group has to be released since all the necessary events of the group did not arrive within the expected time. If a group has timed out but is not yet evicted, it will reject any new elements that want to be added to that group.

* _Group eviction_ is when a group is removed from the aggregator regardless of if it was completed or timed out. If a new element with that group's id is recieved by the aggregator, the group will be created again.

Lastly, as the elements that arrive to group based aggregators are usually related to an splitted sequence, if the events have a *_sequenceNumber_*, they are sorted in increasing order prior to the aggregation release.

==== Parameters
[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]
|======================
| Name | Type | Description | Default Value | Required
| Name | String | The name of the aggregator. It can later be used to be referenced by an aggregator listener | {nbsp}| *x*{nbsp}
| Content | Expression | The expression that defines what is going te be aggregated. The result of the evaluation will be the value stored in the aggregation | #[message] | {nbsp}
| Group Id | Expression | The expression to be evaluated for every new message received in order to get the id for the group where it should be aggregated | #[correlationId] | {nbsp}
| Group Size | Number | The max size to assign to the group with the group ID resolved. All messages with the same group ID must have the same group size. If not, only the first resolved group size will be considered as correct and a warning will be logged for every one that does not match it | #[itemSequenceInfo.sequenceSize] | {nbsp}
| Eviction Time | Number | The time to remember a group ID once it was completed or timed out (0 means: don't remember, -1: remember forever) | 180 | {nbsp}
| Eviction Time Unit | Time Unit | The time unit for the Eviction Time | SECONDS | {nbsp}
| Timeout | Number |  A max time to wait for the aggregation of a group to complete. If the timeout is reached before the total number of elements in that group is equal to the group's size, the aggregation will be considered complete regarding that. A value of 0 is not supported since the group would be timing out constantly | -1(UNLIMITED) | {nbsp}
| Timeout unit | Time Unit | The time unit in which to measure the timeout |  SECONDS | {nbsp}
| Object Store | Object Store |  Either a name to reference a global object store or a definition of a private object store where the aggregated elements will be stored |  Default Object Store partition | {nbsp}
| Aggregation Complete Route | Route |  Components chain that will be executed once the aggregation is complete | {nbsp} | *x*{nbsp}
| Incremental Aggregation Route | Route | Components chain that will be executed for every new element that is aggregated. The payload will be the list of aggregated elements until this moment | {nbsp} | {nbsp}
|======================

==== Raises
* AGGREGATORS:GROUP_COMPLETED
+
{nbsp} When a new element has to be added to an already completed group (And the group was not yet evicted)
* AGGREGATORS:GROUP_TIMED_OUT
+
{nbsp} When a new element has to be added to a group that timed out (And the group was not yet evicted)
* AGGREGATORS:NO_GROUP_ID
+
{nbsp} When the expression that resolves to the group Id returns null
* AGGREGATORS:NO_GROUP_SIZE
+
{nbsp} When the expression that resolves to the group size returns null
* AGGREGATORS:AGGREGATOR_CONFIG
+
{nbsp} When the group size or timeout have invalid values (e.g: groupSize < 0)

[[delete-client]]
=== Delete Client



//== Sources
//
//[[aggregator-listener]]
//=== Aggregator Listener
//`<aggregators:aggregator-listener aggregatorName="exampleAggregator" includeTimedOutGroups="false">`
//
//
//Once the aggregator that is referenced by the listener completes an aggregation, the listener will be triggered with a list of all the elements.
//The aggregation listener can be used for any kind of aggregator but is really important for time driven aggregations. Those will be triggered asynchronously and not within an event context, hence, not executing any aggregator route and only being able to reach components in flows with an aggregator listener as source.
//
//
//==== Parameters
//[cols=".^20%,.^20%,.^35%,.^20%,^.^5%", options="header"]
//|======================
//| Name | Type | Description | Default Value | Required
//| Aggregator Name | String | The name of the aggregator to listen to. Once that aggregator releases it's elements the listener will be executed. Each listener can only reference one aggregator and each aggregator can only be referenced by at most one listener | {nbsp} | *x*{nbsp}
//| Include Timed Out Groups | Boolean | It tells if the listener should be triggered due to a group being released by a timeout | false | {nbsp}
//|======================
//
//== Aggregation attributes
//Each time a message goes through an aggregation, some attributes will be added to it with information about the aggregation.
//
//[cols=".^20%,.^20%,.^35%", options="header"]
//|======================
//| Name | Type | Description
//| Aggregation ID | String | The ID from the group where the element was aggregated. If the aggregation strategy does not aggregate by group, then this field will be an autogenerated value kept until the aggregation is released (e.g: group-based and time-based aggregators)
//| First Item Arrival Time | Date | The time when the first value was aggregated
//| Last Item Arrival Time | Date | The time when the last value was aggregated
//| Is Group Complete | Boolean | True if the aggregation is complete, False otherwise
//|======================
//
//
//
//== Time vs Event driven aggregations
//
//There is a key concept needed to be understood in order to properly work with aggregators. As seen in the configurations, an
//aggregation can be considered complete based on a new value being added to the list (a max size was specified) or because some timeout or time period was completed.
//That separates 2 different kind of triggers for aggregations, sync or event driven and async or time driven. This is important because the type of aggregation will define
//which chain of components will be executed with that list of elements.
//
//First of all, it should be noted that for any time counter associated with an aggregator, it will start counting from the moment the first message of a group arrives. Once the aggregation is complete, it will be reset and wait again until the next element arrives.
//In the case of single group aggregators (time and size based) there will only be one time counter but for the group based aggregator, there is one counter per group.
//
//If an aggregation is released by a time period or timeout completion, it will never execute the routes in it's definition.
//That would lead to an unwanted scenario where only a piece of a flow is executed, starting from the processor's chain
//configured inside the aggregator and continuing with the components that follow it but without having executed
//any precious one from the flow's source to the aggregator itself.
//Meaning that the event must have been created within the aggregator and that is not something we want to do. Besides, if we consider the case of an aggregator inside a try scope where a transaction is started, the transaction context would not be available in the context of the MPs inside the aggregator.
//
//That is why the aggregator listener exists and why the time-based-aggregator does not accept an aggregation-complete-route.
//
//On the other hand, if an aggregation is completed due to a new event being added to the aggregated elements list and reaching a max size,
//then both the aggregation-complete route will be executed and the aggregator listener that is hooked to that aggregator (in case there is one). That is possible because in order to have reached the aggregator,
//the message must have gone through every message processor prior to it and we can be sure that the whole flow was executed from it's source forward.
//
//Bottomline, if expecting an aggregation to be completed synchronously, then you can either define how to process it in a processor's chain inside the very same aggregator (aggregation-complete route) or
//in another flow with an aggregation listener as it source (or both).
//Otherwise, if the aggregation will be triggered by a time period completion, the only way it will be processed is with a processor's chain defined in a separete flow and with an aggregator listener as it source.
//
//
//== Aggregators in a cluster
//
//The module is developed to work in a cluster out of the box but there are some configuration details that need to be taken into account to prevent it to work unexpectedly.
//
//Whenever there is a time driven aggregation defined, once the first event arrives, it will be scheduled in the primary node of the cluster. Since new events will arrive in any node of the cluster, we need some way to notify the primary node and make it schedule that aggregation.
//In order to do that, there is another task in the primary node that checks at a fixed rate if a new aggregation should be scheduled.
//That could lead to a problem because if the interval between checks for new aggregation scheduling is much bigger than the actual timeout of the aggregation, that aggregation could be over before is even scheduled, or there may be big errors in the time computation.
//
//Given all this, there is a way to configure how frequently the primary node will check for new aggregations to be scheduled.
//You can either define this value by a global configuration property (in ms) : `aggregatorsSchedulingPeriod`
//or with a system property `-M-Dmule.aggregatorsSchedulingPeriod`
//
//
//== Object store configuration
//
//For any aggregator, an object store can be configured either by referencing a global OS or creating a private one.
//
//* Global
//[source, xml]
//----
//<aggregators:size-based-aggregator name="globalOSAggregator"
//                                   maxSize="10"
//                                   objectStore="aGlobalObjectStore">
//
//----
//
//* Private
//[source, xml]
//----
//<aggregators:size-based-aggregator  name="privateOSAggregator" maxSize="10">
//    ...
//    <aggregators:object-store>
//        <os:private-object-store alias="privateObjectStore" persistent="false"/>
//    </aggregators:object-store>
//</aggregators:group-based-aggregator>
//----


[[see_also]]
== See Also
* link:aggregator-examples[Aggregators usage examples]

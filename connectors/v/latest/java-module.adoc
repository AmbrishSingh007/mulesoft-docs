= Java Module
:keywords: Java, custom code

== About the Java Module

In contrast with Mule 3, Mule 4 has taken an approach that intends to:

* Minimize the need for custom code
* Do not require the user to know or understand Java

However, we do recognize that advanced uses cases exist which require integrating with custom Java code. Some example uses cases are:

* Need to reuse a tax calculation library
* Need to reuse a canonical object model that's standard in the organization
* Need to execute custom logic and Java is your weapon of choice


In Mule 3, MEL was used as a Java bridge for creating instances of particular classes and execute methods. In Mule 4, DataWeave has replaced MEL as the expression language and that implies changes in the way we interop with Java.  Being a functional language, it doesn’t make sense for DataWeave to be able to execute random instance method on random object instances, since functional languages should not have side effects on its input arguments.

== Java Module vs. Scripting Module

The goals of the Java module could also be achieved executing Groovy code through the link:scripting-module[scripting module]. Advantages of using the Java module over the Scripting one are:

* Scripting module doesn't offer DataSense support. 
Although the scripting module could be used to achieve the same goals using Groovy, the scripting module doesn’t provide DataSense support for it. 


== See also

* link:java-create-instance[Create instances of a class]
* link:java-invoke-method[Invoke methods]
* link:java-instanceof[To test if an object is an instance of a class]
* link:java-refence[Java Module technical reference]
* link:scripting-module[Scripting module documentation]

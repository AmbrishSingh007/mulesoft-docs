= VM Connector
:keywords: VM, queues, connector
////
*Reference:* link:/connectors/vm-connector-reference[VM Connector Reference]
////

Release Notes: link:/release-notes/connectors-vm-1.1.0[Mule Runtime VM 1.1.0 Release Notes]

The VM Connector is used for intra/inter app communication. The communication is done through asynchronous queues, which can be either transient or persistent.

Transient queues are faster, but not reliable in the case of a system crash. Persistent queues, on the other hand are slower but reliable.

When running on a single instance, persistent queues work by serializing and storing the contents into disk. When running in cluster mode, persistent queues are backed by the memory grid instead. This means that when a flow uses the VM connector to publish content to a queue, the Runtime will decide whether to process that message in the same origin node or to send it out to the cluster for another node to pick it up. This is an easy way to distribute load across the cluster.

In either way, transactions are always supported.

== When to use the VM Connector

Use the VM connector when:

* You want to pass messages from a flow to another through a queuing mechanism, instead of using <flow-ref /> directly
* When you want to distribute work across a cluster
* When you want to communicate different applications running on the same Mule domain
* When you need simple queueing which doesn’t justify a full JMS broker

== Defining queues

A config needs to be created to define the queues on which the connector is going to operate. It is possible to define any number of configs,
each one with its own set of queues:

[source, xml, linenums]
----
<vm:config name="vm">
    <vm:queues>
        <vm:queue queueName="transientQueue" queueType="TRANSIENT" />
        <vm:queue queueName="persistentQueue" queueType="PERSISTENT" />
    </vm:queues>
</vm:config>
----

[TIP]
Queues defined within a given config, can only be used by operations referencing that specific config. However, queue names cannot be repeated
accross configs. No two queues with the same name can exists in the same application or domain.

== Persistent queues limitations

When using persistent queues, the messages will either be written to disk or distributed across the cluster, which requires sending the message through the network. In either case, the message needs to be serialized. This requires the contents you send across to be serializable. Even though you can enable Kryo serialization to get a wider range of serializable values, even Kryo has its limitations. So when using persistent queues try to:

* Keep your values simple. Overly complex structures may result in serialization errors or performance issues if they’re not easy to serialize
* When using complex Java objects, make sure they implement the Serializable interface and they conform to the Java bean contract.
* Streams, json objects, maps, etc. are usually fine as long as the associated values also comply with the recommendations above

== See also

* link:/connectors/vm-publish-listen[To publish and listen messages]
* link:/connectors/vm-dynamic-routing[Dynamic Routing with the VM connect]
* link:/connectors/vm-publish-response[To publish a message and get a response]
* link:/connectors/vm-publish-across-apps[To publish a message across applications]
* link:/connectors/vm-reference[VM Connector reference]

= XML Module
:keywords: XML, xpath, xslt, xquery, XSD, validation

The XML Module which provides functionality to process and extract data from an XML document. This module should be used for use cases associated with XML standards such as XSLT, XPath and XQuery or XSD.
+
Although DataWeave is perfectly capable to handle most of XML related use cases (it's acutally Mulesoft's recommended approach), there are still valid use cases for users who want to use XML standards such as XSLT, XPath, XQuery and XSD validation.

 
== When to use the VM Connector

Use the VM connector when:

* You want to pass messages from a flow to another through a queuing mechanism, instead of using <flow-ref /> directly
* When you want to distribute work across a cluster
* When you want to communicate different applications running on the same Mule domain
* When you need simple queueing which doesn’t justify a full JMS broker

== Defining queues

A config needs to be created to define the queues on which the connector is going to operate. It is possible to define any number of configs,
each one with its own set of queues:

[source, xml, linenums]
----
<vm:config name="vm">
    <vm:queues>
        <vm:queue queueName="transientQueue" queueType="TRANSIENT" />
        <vm:queue queueName="persistentQueue" queueType="PERSISTENT" />
    </vm:queues>
</vm:config>
----

[TIP]
Queues defined within a given config, can only be used by operations referencing that specific config. However, queue names cannot be repeated
accross configs. No two queues with the same name can exists in the same application or domain.

== Persistent queues limitations

When using persistent queues, the messages will either be written to disk or distributed across the cluster, which requires sending the message through the network. In either case, the message needs to be serialized. This requires the contents you send across to be serializable. Even though you can enable Kryo serialization to get a wider range of serializable values, even Kryo has its limitations. So when using persistent queues try to:

* Keep your values simple. Overly complex structures may result in serialization errors or performance issues if they’re not easy to serialize
* When using complex Java objects, make sure they implement the Serializable interface and they conform to the Java bean contract.
* Streams, json objects, maps, etc. are usually fine as long as the associated values also comply with the recommendations above

== See also

* link:/connectors/vm-publish-listen[To publish and listen messages]
* link:/connectors/vm-dynamic-routing[Dynamic Routing with the VM connect]
* link:/connectors/vm-publish-response[To publish a message and get a response]
* link:/connectors/vm-publish-across-apps[To publish a message across applications]
* link:/connectors/vm-reference[VM Connector reference]

= Using XPath with the XML Module
:keywords: XML, xpath

The `<xml-module:xpath-extract>` operation supports evaluation of XPath expressions.

Because XPath expressions can match any number of individual elements, this operation returns a List of Strings. If no element matched the expression, an empty list will be returned.

XPath expressions are also namespace aware, which is why this operation allows namespace mappings. These mappings will be merged with those optionally defined in the referenced namespace-directory, meaning that the evaluation will combine both sets of namespace mappings.

[TIP]
Although we support the XPath standard, remember that DataWeave is capable of achieving the same use cases and Mulesoft's recommended tool for extracting/transforming XML documents

As an example, let's look at how to work with a sample XML which contains the script of the play Othello by William Shakespeare. The XML file looks roughly like this:

[source, xml, linenums]
----
<?xml version="1.0"?>
<!--<!DOCTYPE PLAY SYSTEM "play.dtd">-->
<PLAY>
    <TITLE>The Tragedy of Othello, the Moor of Venice</TITLE>
    <FM>
        <P>Text placed in the public domain by Moby Lexical Tools, 1992.</P>
        <P>SGML markup by Jon Bosak, 1992-1994.</P>
        <P>XML version by Jon Bosak, 1996-1998.</P>
        <P>This work may be freely copied and distributed worldwide.</P>
    </FM>
    <PERSONAE>
        <TITLE>Dramatis Personae</TITLE>

        <PERSONA>DUKE OF VENICE</PERSONA>
        <PERSONA>BRABANTIO, a senator.</PERSONA>
        <PERSONA>Other Senators.</PERSONA>
        <PERSONA>GRATIANO, brother to Brabantio.</PERSONA>
        <PERSONA>LODOVICO, kinsman to Brabantio.</PERSONA>
        <PERSONA>OTHELLO, a noble Moor in the service of the Venetian state.</PERSONA>
        <PERSONA>CASSIO, his lieutenant.</PERSONA>
        <PERSONA>IAGO, his ancient.</PERSONA>
        <PERSONA>RODERIGO, a Venetian gentleman.</PERSONA>
        <PERSONA>MONTANO, Othello's predecessor in the government of Cyprus.</PERSONA>
        <PERSONA>Clown, servant to Othello. </PERSONA>
        <PERSONA>DESDEMONA, daughter to Brabantio and wife to Othello.</PERSONA>
        <PERSONA>EMILIA, wife to Iago.</PERSONA>
        <PERSONA>BIANCA, mistress to Cassio.</PERSONA>
        <PERSONA>Sailor, Messenger, Herald, Officers, Gentlemen, Musicians, and Attendants.</PERSONA>
    </PERSONAE>

    <SCNDESCR>SCENE  Venice: a Sea-port in Cyprus.</SCNDESCR>
    <PLAYSUBT>OTHELLO</PLAYSUBT>
    <ACT><TITLE>ACT I</TITLE>
    <SCENE><TITLE>SCENE I.  Venice. A street.</TITLE>
    <STAGEDIR>Enter RODERIGO and IAGO</STAGEDIR>
    <SPEECH>
        <SPEAKER>RODERIGO</SPEAKER>
        <LINE>Tush! never tell me; I take it much unkindly</LINE>
        <LINE>That thou, Iago, who hast had my purse</LINE>
        <LINE>As if the strings were thine, shouldst know of this.</LINE>
    </SPEECH>

.....
<!-- A LOT MORE CONTENT -->
----

Let's suppose you want to extran all the lines that contain the work `handkerchief`

[source, xml, linenums]
----
<xml-module:xpath-extract xpath="//LINE[contains(., $word)]"> // <1>
    <xml-module:context-properties>#[{'word': 'handkerchief'}]</xml-module:context-properties> // <2>
</xml-module:xpath-extract>
----

<1> We provide an XPath expression which uses the `$` prefix to reference context properties
<2> We use DataWeave in the `context-properties` parameter to produce the context properties

This will output the following List of Strings (each line will be a different item in the list):

```
<LINE>For the same handkerchief?</LINE>
<LINE>What handkerchief?</LINE>
<LINE>What handkerchief?</LINE>
<LINE>Have you not sometimes seen a handkerchief</LINE>
<LINE>I know not that; but such a handkerchief--</LINE>
<LINE>Where should I lose that handkerchief, Emilia?</LINE>
<LINE>Lend me thy handkerchief.</LINE>
<LINE>That handkerchief</LINE>
<LINE>Fetch me the handkerchief: my mind misgives.</LINE>
<LINE>The handkerchief!</LINE>
<LINE>The handkerchief!</LINE>
<LINE>The handkerchief!</LINE>
<LINE>Sure, there's some wonder in this handkerchief:</LINE>
<LINE>But if I give my wife a handkerchief,--</LINE>
<LINE>But, for the handkerchief,--</LINE>
<LINE>Boding to all--he had my handkerchief.</LINE>
<LINE>--Handkerchief--confessions--handkerchief!--To</LINE>
<LINE>--Is't possible?--Confess--handkerchief!--O devil!--</LINE>
<LINE>mean by that same handkerchief you gave me even now?</LINE>
<LINE>By heaven, that should be my handkerchief!</LINE>
<LINE>And did you see the handkerchief?</LINE>
<LINE>That handkerchief which I so loved and gave thee</LINE>
<LINE>By heaven, I saw my handkerchief in's hand.</LINE>
<LINE>I saw the handkerchief.</LINE>
<LINE>It was a handkerchief, an antique token</LINE>
<LINE>O thou dull Moor! that handkerchief thou speak'st of</LINE>
<LINE>How came you, Cassio, by that handkerchief</LINE>
```

By default, the operation will will attempt to transform an XML document at the message payload. You can however use the `content` parameter to supply the input document:

[source, xml, linenums]
----
<flow name="linesFromOthello">
    <file:read path="othello.xml" target="othello" />
    <xml-module:xpath-extract xpath="//LINE[contains(., $word)]>
        <xml-module:content>#[vars.othello]</xml-module:content>
        <xml-module:context-properties>#[{'word': 'handkerchief'}]</xml-module:context-properties>
    </xml-module:xpath-extract>
</flow>
----

In this example you can see how we get the content from someplace else (in this case a file in the filesystem) and then reference it using a simple expression.

== Mapping Namespaces

There are cases in which the input XML document may contain elementes of different namespaces. For example, consider the following document:

[source, xml, linenums]
----
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body foo="bar">
    <ns1:echo xmlns:ns1="http://simple.component.mule.org/">
      <ns1:echo>Hello!</ns1:echo>
    </ns1:echo>
  </soap:Body>
</soap:Envelope>
----

Let's look at an example for this use case:

[source, xml, linenums]
----
 <flow name="xpathWithInlineNs">
    <xml-module:xpath-extract xpath="/soap:Envelope/soap:Body/mule:echo/mule:echo">
        <xml-module:namespaces>
            <xml-module:namespace prefix="soap" uri="http://schemas.xmlsoap.org/soap/envelope/"/>
            <xml-module:namespace prefix="mule" uri="http://simple.component.mule.org/"/>
        </xml-module:namespaces>
    </xml-module:xpath-extract>
</flow>
----

In this example you can see how to map the prefixes used in the XPath expressions to the corresponding namespace URIs.

But what happens if you actually need to execute several XPath expressions which use the same namespaces? You definitively don't want to do the mapping each time. In that case, you can create a `namespace-directory` to contain the mappins and then reference it:

[source, xml, linenums]
----
<xml-module:namespace-directory name="fullNs"> // <1>
    <xml-module:namespaces>
        <xml-module:namespace prefix="soap" uri="http://schemas.xmlsoap.org/soap/envelope/"/>
        <xml-module:namespace prefix="mule" uri="http://simple.component.mule.org/"/>
    </xml-module:namespaces>
</xml-module:namespace-directory>
    
<flow name="xpathWithFullNs">
    <xml-module:xpath-extract xpath="/soap:Envelope/soap:Body/mule:echo/mule:echo" // <2>
         namespaceDirectory="fullNs"/> // <3>
</flow>
----

<1> The `namespace-directory` element is used to map prefixes to the actual namespace URIs. Notice this prefixes should match those used in the input document
<2> You can then reference those prefixes in your XPath expresion. 
<3> Finally, use the `namespaceDirectory` parameter to reference the mapping created in step 1.

Finally, you can combine use cases! You can have a global `namespaceDirectory` which contains some mappings and then add additional ones at the operation level. This would be useful if you had a bunch of document that, for example, all contain the `soap` namespace, but there's only one which contains the `mule` namespace:

[source, xml, linenums]
----
<xml-module:namespace-directory name="partialNs"> // <1>
    <xml-module:namespaces>
        <xml-module:namespace prefix="soap" uri="http://schemas.xmlsoap.org/soap/envelope/"/>
    </xml-module:namespaces>
</xml-module:namespace-directory>

<flow name="xpathWithMergedNs">
    <xml-module:xpath-extract xpath="/soap:Envelope/soap:Body/mule:echo/mule:echo" // <2>
    namespaceDirectory="partialNs"> // <3>
        <xml-module:namespaces>
            <xml-module:namespace prefix="mule" uri="http://simple.component.mule.org/"/> // <4>
        </xml-module:namespaces>
    </xml-module:xpath-extract>
</flow>
----

<1> Declare a `namespace-directory` just like before, but only supply the common namespaces
<2> Provide your XPath expression
<3> Reference the partial namespace directory
<4> Provide the additional mapping

[TIP]
In any of the examples above, the prefixes used in the mappings and XPath expressions must match the ones used in the input document

== Using XPath as a function

The XML module also contributes a DataWeave function for extracting values using XPath. This is useful in cases such as a `<choice>` or `<foreach>` routers.

[TIP]
You can use this function inside any DataWeave transformation

=== Using XPath function with <foreach>

Going back to the Othello lines example, imagine what what you really want is to iterate through all those lines and process them separatelly:

[source, xml, linenums]
----
<foreach collection="#[XmlModule::xpath('//LINE', payload, {})]">
    <flow-ref name="processLine" />
</foreach>
----

1. The first argument is the XPath expression
2. The second one is the input document, in this case, the message payload
3. The third one is the context properties. Since in this case we don't need any, we just pass an empty object (`{}`)

=== Using XPath function with <choice>

Going back to the previous example, suppose you want to do something if the input document does not contain the word `handkerchief`

[source, xml, linenums]
----
<choice>
    <when expression="#[isEmpty(XmlModule::xpath('//LINE[contains(., \$word)]', vars.untrustedOthello, {'word': 'handkerchief'}))]">
        <flow-ref name="alteredOthello" />
    </when>
</choice>
----

1. Since the `XmlModule::xpath` function returns a list, we use DataWeave's `isEmpty()` function to test if the output is empty or not
2. The first argument of the XPath function is an expression, this time using the `$work` context property
3. The second argument is the input document, this time sitting in a variable
4. Lastly, we provide the context properties values

== See also

* link:xml-module[XML Module documentation]

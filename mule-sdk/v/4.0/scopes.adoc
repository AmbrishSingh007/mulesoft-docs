= Creating Scopes with Mule SDK
:keywords: mule, sdk, scopes, scope, components

Scopes are pretty similar to <<operations#, Operations>>, but whose execution includes executing
other child <<operations#, Operations>>.
This means that a Scope is basically an Operation that receives one or more arguments that are
simple <<parameters#, Parameters>> along with a single Chain component and the CompletionCallback.

A Chain represent the child <<operations#, Operations>> declared inside the Scope by the
application developer and provide an abstraction to execute them.

== Declaring a Scope

Let's see the basic structure of a Scope with a decorator example. +
Here we'll have the Chain to be executed and the CompletionCallback to invoke once the
scope execution is done _(yes, all Scopes are declared as <<non-blocking-operations#, Non-Blocking Operations>>)_:

[source,java,linenums]
----
@Extension(name = "Docs")
@Operations(LogDecorator.class)
public class DocsModule {

}
----

[source,java,linenums]
----
public void logDecorator(Chain operations,
                         CompletionCallback<Object, Object> callback) {

  LOGGER.debug("Invoking child operations")
  operations.process(
    result -> {
      LOGGER.debug(result.getOutput());
      callback.success(result);
    },
    (error, previous) -> {
      LOGGER.error(error.getMessage());
      callback.error(error);
    });
}
----

Of course, if we receive a Chain of <<operations#, Operations>>, we need to execute
them in some way, and that's exactly what the `process(successCallback, errorCallback)` does.
With it, we are executing the Chain in a Non-Blocking fashion and listening for the
results in case of Success or Error. +
Here our `successCallback` is called with the execution Result when a
successful execution is completed by _all_ the <<operations#, Operations>> in the Chain,
while the `errorCallback` will be called when an error occurs during the execution of
_any_ child <<operations#, Operations>> with both the error and the last successful
result as arguments.

At this point you might be asking yourself, how is this used in a mule application?
Lucky us, it's pretty simple:

[source,xml,linenums]
----
<flow name="logDecoratorSampleFlow">
    <docs:log-decorator>
        <http:request config-ref="config" path="/" method="GET"/>
    </docs:log-decorator>
</flow>
----

This will execute the `http:request` child operation wrapped by the `LOGGER` invocations.
Very simple, right? Any amount of <<operations#, Operations>> can be executed
inside our scope, including other Scopes or Routers.


== Adding Parameters

We mentioned that Scopes could also receive other simple `@Parameters` and `@ParameterGroups`.
I say _simple_ because Scopes are not allowed to receive _complex_ parameters that
are declared as child elements. Say you want to customize the log level of the decorator, you'll be able to receive that as a Parameter:

[source,java,linenums]
----
public void logDecorator(@Optional(defaultValue="true") boolean debug,
                         Chain operations,
                         CompletionCallback<Object, Object> callback) {

  if (debug){
    LOGGER.debug("Invoking child operations")
  }
  operations.process(
    result -> {
      Object message = result.getOutput();
      if (debug){
        LOGGER.debug(message);
      } else {
        LOGGER.info(message);
      }
      callback.success(result);
    },
    (error, previous) -> {
      LOGGER.error(error.getMessage());
      callback.error(error);
    });
}
----

With a minimal change in our Scope's API:

[source, xml, linenums]
----
<flow name="logDecoratorSampleFlow">
    <docs:log-decorator debug="false">
        <http:request config-ref="config" path="/" method="GET"/>
    </docs:log-decorator>
</flow>
----

By default, Chains are executed using the Message that was received by the container
Scope, but other definitions of the `process` method allow  the user to customize the `payload` and
`attributes` that will be used to execute the Chain. You may find the full reference here.

== Using Stereotypes

`Stereotypes` can be used to limit which <<operations#, Operations>> are allowed to exist inside a Chain,
enforcing consistency in its usage. Only the <<operations#, Operations>> that have the given `Stereotypes` can be declared inside our Scope.

[source, java, linenums]
----
public void assertAll(@AllowedStereotypes(AssertionStereotype.class) Chain assertions,
                @Optional boolean failOnError,
                CompletionCallback<Boolean, Void> callback) {
  assertions.process(
    result -> {
      callback.success(Result.<Boolean, Void>builder().output(true).build());
    },
    (error, previous) -> {
      if (failOnError){
        callback.error(error);
      } else {
        callback.success(Result.<Boolean, Void>builder().output(false).build());
      }
    });
}
----

[source, xml, linenums]
----
<flow name="logDecoratorSampleFlow">
    <docs:assert-all>
      <docs:not-null value="#[payload]">
      <docs:not-empty-collection value="#[payload]">
    </docs:assert-all>
</flow>
----

== Restrictions

// TODO intro

=== Config-less and Connection-less

Scopes have some restrictions that differentiate them from <<operations#, Operations>>.
By definition, Scopes are not allowed to depend on nor receive a particular
<<configs#, Configuration>> nor <<connections#, Connection>>. +

=== Only one Chain

The Chain component is key in the definition of a Scope, thus it is _required_ to have one and _only_ one Chain argument.

=== Always Non Blocking
// TODO linking to CompletionCallback
All Scopes have to be defined as a `void` method receiving a `CompletionCallback` for communicating it's
Result, which means that all the Scopes are non-blocking by default.

= Validators with Mule SDK
:keywords: validation, validators, mule, sdk

==  What is a Validator?

Validators are operations that are used to perform a validation of the Mule Message. These
validators make no change to the Mule Message. There are two outcomes when placing a validator
on a flow:

* If the condition the validator imposes is fulfilled, the flow continues and the Mule Message
  remains unchanged.

* If the condition the validator imposes is not fulfilled, an error will be thrown.

== What are the Requirements for a Validator?

For an operation to be a validator, it should comply with these requirements:

* It should be reached by the `@Validator` annotation. This can either be assigned at the
  class level or at method level. By using the `@Validator` annotation at a class level,
  all public methods will be marked as Validators.

* It should return `void`.

* It should throw at least one error that is or extends from `MULE:VALIDATION`. Upon
  a validation failure, validators must throw a Mule validation error or a child of one.

The `@Validator` annotation makes the methods be of the Stereotype `ValidatorStereotype`. Because components cannot have two stereotypes, you cannot assign another stereotype to them.

These validators share the same UX as operations. Once your module is added for use in Studio, the
validators will appear on the palette. When adding a validator to a flow, its parameters will be assigned
just as if it was an operation.

== How to Make a Validator

This example shows how to make a simple validator. It creates a simple extension named `balance`:

[source,java,linenums]
----
@Operations({BalanceOperations.class})
@Extension(name = "balance")
@ErrorTypes(BalanceError.class)
public class BalanceExtension {

}
----

The `BalanceOperations` class below adds our validation method, annotated with `@Validator`. The
method throws an error type that comes from the generic validation error type. Note that you
can also annotate the class `BalanceOperations` with `@Validator`, but in that case, any other operations
on it would also be flagged as validators.

[source,java,linenums]
----
public class BalanceOperations {
  @Validator
  @Throws(BalanceErrorsProvider.class)
  public void hasSufficientFunds(Integer balance, Integer price) throws Exception {
    if (price > balance){
      throw new ModuleException(BalanceError.INSUFFICIENT_FUNDS, new IllegalArgumentException("There is not enough money to make the transaction"));
    }
  }
}
----

This example creates the error that will be thrown if the validation fails. Notice that it is
named according to the validations failure.

[source,java,linenums]
----
public enum BalanceError implements ErrorTypeDefinition<BalanceError> {
  INSUFFICIENT_FUNDS(MuleErrors.VALIDATION);

  private ErrorTypeDefinition<? extends Enum<?>> parent;

  BalanceError(ErrorTypeDefinition<? extends Enum<?>> parent) {
    this.parent = parent;
  }

  @Override
  public Optional<ErrorTypeDefinition<? extends Enum<?>>> getParent() {
    return Optional.ofNullable(parent);
  }
}
----

The validator method needs an `ErrorTypeProvider` that knows all the error types
the validation can throw. In this case, we create an `ErrorTypeProvider` that says that the
only error the method can throw is of type *BALANCE:INSUFFICIENT_FUNDS*.

[source,java,linenums]
----
public class BalanceErrorsProvider implements ErrorTypeProvider {
  @Override
  public Set<ErrorTypeDefinition> getErrorTypes() {
    HashSet<ErrorTypeDefinition> errors = new HashSet<>();
    errors.add(BalanceError.INSUFFICIENT_FUNDS);
    return errors;
  }
}
----

== How To Use Validators

Assume that you want to use the validator that was created before on a flow. The syntax
will be the same as if it were an operation. Because `balance` and `price` are required parameters,
it is necessary to assign those. In this case, the validation is made with the values in the variables
`price` and `balance`, but you could use any expression there:

[source,xml,linenums]
----
<balance:has-sufficient-funds balance="#[vars.balance]" price="#[vars.price]"/>
----

== Validators and the "All" Scope

Because validators are of the Stereotype `ValidatorStereotype`, they can be used in the `all` scope from the
Validation module. Here is an example that shows how to do this.

This example uses a validator from the Validation module. It also assumes that there is
a number extension that has a validator named `isPositive` that validates whether a
value is in fact positive.

[source,xml,linenums]
----
<validation:all>
  <validation:is-not-blank-string value="#[vars.buyerName]"/>
  <number:is-positive value="#[vars.price]"/>
  <number:is-positive value="#[vars.balance]"/>
  <balance:has-sufficient-funds balance="#[vars.balance]" price="#[vars.price]"/>
</validation:all>
----

This example checks that there is a variable `buyerName` that is not an empty string. After
that, it ensures that both variables, `price` and `balance`, have positive values. Finally, it checks whether
there is a sufficient balance on the account with the validator.

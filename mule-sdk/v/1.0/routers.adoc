= Creating Routers with Mule SDK
:keywords: mule, sdk, routers, router

Conceptually, Routers are <<operations#, Operations>> that can receive many executable Routes along with a set of
Parameters, handling the execution of at one, all of none of them.

Routes should be used for receiving multiple possible paths of execution, where the Parameters
of the Route can be used to decide whether or not the contained processors should be executed.
Stereotypes can be used in the Route declaration to define which are the allowed stereotypes of
contained Chain. Routes will not allow complex parameters to be defined inline,
since the DSL content of the element will be exclusive of the parameterized <<operations#, Operations>>.

== Defining a Route

First things first, we need to declare at least one Route in our Module by extending
the `Route` base class:

[source,java,linenums]
----
public class WhenRoute extends Route {

  @Parameter
  @Optional
  private boolean shouldExecute;

  public boolean shouldExecute() {
    return shouldExecute;
  }

}
----

== Declaring the Router

Next thing is to declare the Router method as one of the Module's <<operations#, Operations>>.
Any Operation receiving at least one Route implementation along with a `RouterCompletionCallback` will be registered as a Router:

[source,java,linenums]
----
@Extension(name = "Docs")
@Operations(ChoiceRouter.class)
public class DocsModule {

}
----

In the `ChoiceRouter` class we define the following method:

[source,java,linenums]
----
public void choice(WhenRoute when,
                   @Optional OtherwiseRoute otherwise,
                   RouterCompletionCallback callback) {

  if (when.shouldExecute()) {
    when.getChain().process(callback::success, (error, previous) -> callback.error(error));

  } else if (otherwise != null && otherwise.shouldExecute()) {
    otherwise.getChain().process(callback::success, (e, r) -> callback.error(e));

  } else {
    callback.success(Result.builder().build());
  }
}
----

Above you can see how a Router is declare and how the Routes are conditionally executed based on
their configuration. Routes execution is performed through their Chain, exactly as if each Route was an Scope by itself.

Using the Router consist in configuring the Router Parameters and then adding each Route declaration
with their own Parameters:

[source,xml,linenums]
----
<flow name="logDecoratorSampleFlow">
    <docs:choice>
      <docs:when shouldExecute="#[payload != null]">
        <http:request config-ref="config" path="/" method="GET"/>
      </docs:when>
      <docs:otherwise>
        <logger message="Payload was null"/>
      </docs:otherwise>
    </docs:choice>
</flow>
----

This will execute the `http:request` operation wrapped contained by the `when` Route every time the `payload`
is not null. If a null `payload` arrives, then the fallback `otherwise` is executed.

// == Restrictions
// TODO ZARAZA

=== Config-less and Connection-less

Routers have some restrictions that differentiate them from <<operations#, Operations>>.
By definition, Routers are not allowed to depend on nor receive a particular Configuration nor Connection. +

=== Always Non Blocking

All Routers have to be defined as a `void` method receiving a `RouterCompletionCallback`
for communicating it's Result, which means that all the Routers are non-blocking by default.

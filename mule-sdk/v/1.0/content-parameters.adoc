= The Content Parameters

[[_content-parameters]]

Consider the following example operation (pseudo code):

[source, xml, linenums]
----
<file:write path="hello.txt" overwrite="true" content="#[payload]" />
----

If you look closely into it, you’ll notice that the parameters that compose them often play different roles.

== Behavior parameters

These are parameters which manage settings regarding how the operation is going to behave. In the example above the overwrite parameter configures what to do if the file
already exists. The path parameter configures where is the content going to be written. They configure the operation, but since we’re talking about a write operation,
they do not represent the main concept which is the data to be written.

There’re also examples of operations which are exclusively formed by behavior parameters. For example:

[source, xml, linenums]
----
<file:copy from="somePath" to="anotherPath" />
----

Both of these parameters are behavior ones since this operation doesn’t take any content. The content is in the file being copied.

== Content Parameters

Considering the explained above, the definition of a content parameter is at this point obvious. In the `file:write` example, the content is a `@Content` parameter.

Content parameters have the following characteristics:

* They must accept expressions. Both SUPPORTS_EXPRESSIONS and EXPRESSION_REQUIRED are supported, but compilation will fail if `@Expression(NOT_SUPPORTED)` is used.
* Each content parameter allows embedding it’s very own DataWeave script to generate it. Therefore, inline definition of content parameters is not allowed
* Content parameters always translate to the DSL as a text element, precisely to enable the embedded DataWeave script

So, let’s consider the `file:write` operation again, but this time let’s see how it actually looks if using content parameters. Suppose that you’re using this operation
in a flow and by the time you’re using this operation the message payload is a json and you want to store it as XML.

[source, xml, linenums]
----
<file:write path="myFile.xml">
	<file:content>
		<![CDATA[#[
        %dw 2.0
        output application/xml
        ---
        rootElement: payload
        ]
        ]]>
	</file:content>
</file:write>
----

On the module's code, the content parameter is marked using the `@Content` annotation:

[source, java, linenums]
----
public void write(String path, @Content InputStream content) {
    // write code
}
----

== Primary Content parameter

The explained above works fine when the operation has only one content parameter, but there’re cases in which the operation has many content parameters. For example:

[source, xml, linenums]
----
<http:request path="/my/api">
	<http:request-builder>
		<http:body>
			#[body..]
		</http:body>
		<http:uri-params>
			#[uri-params …]
		</http:uri-params>
		<http:headers>
			#[you get the picture..]
		</http:headers>
	</http:request-builder>
</http:request>
----

As you can see, you can have as many content parameters as you want, which means that the `@Content` annotation can be used on more than one method argument.
However, the body parameter is still more important than the rest, because although headers are also part of the content being sent in the http request, those headers
are complementary to the actual body being sent. So, when an operation has more than one content parameter, one of them has to be marked as the primary content.
You do so by using `@Content(primary = true)`.

The primary content parameter has all of the same characteristics as the regular content parameters, plus two additional things:

* They’re automatically made optional
* They automatically default to `#[payload]`

These two features are automatically added to the parameter by the runtime.

[TIP]
Going back to the `file:write` example in which there was only one content parameter: is it primary? _YES_. When an operation has only one content parameter,
the SDK will automatically consider it as primary. That means that the content parameter in the `file:write` operation is automatically made optional and defaults
to `#[payload]`. This helps to enforce consistency across modules.

== Changing the default of a primary content

There’re edge cases in which a primary content should default to something else than the payload. This tends to happen more when the operation has only one content
parameter and that parameter is not always needed. For example, consider the Database connector. The input parameters of a select query are primary content, but not
all queries require input parameters. So the real default here should be an empty map.

You can do that by combining the `@Content` and `@Optional` annotations. For example, the following sets the default to an empty map:

[source, java, linenums]
----
public List<Map> select(@Text String sql,
                        @Optional(defaultValue="#[{}]") @Content Map<String, Object> inputParameters) {
	// select
}
----

We can also set the content parameter as optional, with no default at all:

[source, java, linenums]
----
public List<Map> select(@Text String sql,
                        @Optional @Content Map<String, Object> inputParameters) {
	// select
}
----

Finally, you can also combine the `@Content` annotation with `@NullSafe`.

[source, java, linenums]
----
public List<Map> select(@Text String sql,
                        @Optional @NullSafe @Content Map<String, Object> inputParameters) {
	// select
}
----

[TIP]
Examples 1 and 3 are perfectly equivalent. The `@NullSafe` option is preferred though since it gives the
module's user a better experience. Having `#[{}]` as an explicit default may be confusing for non experienced
Mule users.

== Embedding content parameters in parameter groups

Looking closely at the `http:request` operation, you’ll see that the content parameters are contained
in an element called `request-builder`. That’s because, for usability reasons, the author of the
connector chose to group all the request related attributes into an enclosing object. This is supported
by the SDK in the following manner:

[source, java, linenums]
----
public void request(String path, @ParameterGroup(showInDsl=true) HttpRequestBuilder requestBuilder) {
    // request
}
----

As you can see, no content parameters here. However, if we look inside the `HttpRequestBuilder` class:

[source, java, linenums]
----
public class HttpRequestBuilder {

    @Parameter
    @Content(primary = true)
    private InputStream body;

    @Parameter
    @Content
    @NullSafe
    private Map<String, String> uriParams;

    @Parameter
    @Content
    @NullSafe
    private Map<String, String> uriParams;
}
----

[TIP]
Removing the `@ParameterGroup` annotation from the `HttpRequestBuilder` argument in the sample request
operation will result in a compilation error. `@Content` is not allowed in complex types.

= Special Parameters
:keywords: mule, sdk, operation, source, MIME, MIME Type, Encoding, Typed Value, Parameter Resolver, literal

== TypedValue<Type>

A common use case for <<operations#, Operations>> and <<sources#, Sources>> is
to receive, along side of the real value of the Parameter, is the Media Type
information about it, look the following example:

[source, java, linenums]
----
public void receiveContent(InputStream content) {
  // operation logic
}
----

[source, xml, linenums]
----
<flow name="mediaTypeFlow">
    <set-payload value="#[output application/json --- { key : 'value'}]">
    <cool-extension:receive-content content="#[payload]" />
</flow>
----

In the Mule App you can see that you are receiving a `JSON` value, but inside the
Operation's code is not possible to easily know which is the *MIME Type* and
*encoding* that represent the `content` parameter value.

=== Using TypedValue Parameters

To be able to retrieve the Media Type information, *MIME Type* and
*encoding*, you simple need to wrap the parameter type into a `TypedValue<OriginalType>`.
Look at the following example, using the same Mule Application but using a `TypedValue` parameter.:

.Media type friendly parameter
[source, java, linenums]
----
public void receiveContent(TypedValue<InputStream> content) {
    DataType dataType = content.getDataType();
    MediaType mediaType = dataType.getMediaType();
    boolean streamType = dataType.isStreamType();
    Long lenght = content.getLength().orElse(-1L);

    InputStream theContent = content.value(); // The proper value

    System.out.println(mediaType);  // application/json; UTF-8
    System.out.println(streamType); // true
    System.out.println(lenght);     // 18
}
----

The usage of `TypedValue` parameters is highly recommended for use cases
where the `MIME Type` information is required to communicate with other systems
that rely on this or to be able how to handle the parameter value.

[[literal]]
== Literal<Type>
`Literal<Type>` parameters allows to get values as they were written
in the Mule Application, this means, if the user wrote an expression like:
`\#[attributes.queryParams]` the operation will able to retrieve a String with
the expression `#[attributes.queryParams]`. This prevents the Mule runtime
from resolving expressions or applying any transformations. This is useful when
such evaluation should be delegated into a third party.

In the particular case of configurations and connection providers, using literal
parameters <<static-dynamic-configs#, allows that configuration to be treated
as a static one instead of dynamic>>. This is so because the literal value is
constant, even if that literal is actually an expression. Because the runtime
won't be evaluating it automatically, it's an static value, from the extension's
point of view.

If the value was provided as an expression, this class will provide such expression but
will offer no way to actually evaluate it. Use <<parameter-resolver, parameter resolvers>>
for that.

[source, xml, linenums]
----
<flow name="literalFlow">
    <cool-extension:literal-value content="#[payload]" />
</flow>
----

.Literal Parameter
[source, java, linenums]
----
public void literalValue(Literal<InputStream> literal) {
    System.out.println(literal.getLiteralValue().get());  // #[payload]
    System.out.println(literal.getType()); // java.io.InputStream
}
----

IMPORTANT: A consideration to have is the generic type. The parameter derived
from uses of this interface will have its type set according to the generic type.
The generic is not optional

[[parameter-resolver]]
== ParameterResolver<Type>
`ParameterResolver<Type>` parameter allows to differ the expression resolution,
this useful when the parameter value is not always required, so as a performance
improvement is not resolve the expression automatically and resolve it at demand
inside the connector's code.

In comparison with <<literal, `Literal<Type>`>> parameters, a
`ParameterResolver<Type>` parameter with an expression will be still considered
a dynamic parameter no matter if the value is resolved or not.

=== Resolving Expression

When a `ParameterResolver<Type>` is received to resolve the expression value
the `resolve()` method must be called, this will return the result of the expression.

WARNING: Because of the expression resolution being differed until is required,
the `resolve()` method can fail due to an invalid expression.

=== Getting the expression value

`ParameterResolver<Type>` parameters can communicate the used expression for
the parameter, this method returns an `Optional<String>` because of the parameter
could have been configured using an expression or not, in the later case,
an `Optional.emtpy()` will be returned.

==== Example: With Expression

[source, xml, linenums]
----
<flow name="expressionParameterResolver">
  <cool-extension:add-products products="#[{Potatoes : 2 , Oranges : 4}]"/>
</flow>
----

[source, java, linenums]
----
public void addProducts(ParameterResolver<Map<String,Integer>> products) {
    System.out.println(map.getExpression().get());  // #[{Potatoes : 2 , Oranges : 4}]
    System.out.println(map.resolve()); // {Potatoes=2, Oranges=4}
}
----

==== Example: Without Expression

[source, xml, linenums]
----
<flow name="noExpressionParameterResolver">
    <cool-extension:add-products>
        <cool-extension:products>
          <cool-extension:product key="Potatoes" value="2"/>
          <cool-extension:product key="Oranges" value="4"/>
        </cool-extension:product>
    </cool-extensions:add-products>
</flow>
----

[source, java, linenums]
----
public void addProducts(ParameterResolver<Map<String,Integer>> products) {
    System.out.println(map.getExpression().isPresent());  // false
    System.out.println(map.resolve()); // {Potatoes=2, Oranges=4}
}
----

== Stacking Types

These special parameters explained above gives special capabilities, but
probably is required to have two capabilities at the same time like still receiving
the Media Type of the given value, but having the possibility of differ the resolution.

To do this, is simply required to stack the generics of the wanted capabilities.

[source, xml, linenums]
----
<flow name="stackedTypes">
  <cool-extension:add-products products="#[output application/json --- {Potatoes : 2 , Oranges : 4}]"/>
</flow>
----

[source, java, linenums]
----
public void addProducts(ParameterResolver<TypedValue<InputStream>> products) {
    System.out.println(map.getExpression().get());  // #[output application/json --- {Potatoes : 2 , Oranges : 4}]
    TypedValue<InputStream> content = map.resolve();
    System.out.println(content.getValue()); // {"Potatoes" : "2", "Oranges" : "4"}
}
----

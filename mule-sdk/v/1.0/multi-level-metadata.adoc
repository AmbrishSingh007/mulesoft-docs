= Multi Level Metadata

The metadata key id does not always need to be a `String` type. It can be a complex type that
holds the necessary information to resolve the metadata. Imagine the case where the user
will use an operation that invokes an action provided by a service. To know the metadata of what the action
require as arguments or what it returns, you will have to know which is the service and which is the action
to be executed, this will be your metadata key id.

The different parameters of the metadata key must have an order in which they will have
to be filled. This order will be a number starting on 1. Returning to the same example, the user
will fill the service field first and then which action to invoke. Then, the service
parameter will have the order 1 and the action parameter order 2.

All the parameters of the `MetadataKeyId` must be annotated with the @MetadataKeyPart annotation with
the order value set. These annotated fields must be of type `String`.

This is an example of how would this metadata key id class look like:

[source, java, linenums]
----
public class ActionIdentifier{

  @Parameter
  @MetadataKeyPart(order = 1) // <1>
  private String service;

  @Parameter
  @MetadataKeyPart(order = 2) // <1>
  private String action;

  public ActionIdentifier(){}

  public ActionIdentifier(String service, String action) {
    this.service = service;
    this.action = action;
  }

  @Override
  public String getService() {
    return service;
  }

  @Override
  public String getAction() {
    return action;
  }
}
----

This is an example of an operation that uses a `MetadataKeyId` that is a complex type :

[source, java, linenums]
----
@OutputResolver(output = OutputOperationTypeResolver.class)
public Object invoke( @ParameterGroup(name = "Operation") @MetadataKeyId(OperationTypeKeysResolver.class) ActionIdentifier identifier,
                      @TypeResolver(InputOperationTypeResolver.class) Map<String, String> args){
  return invokeAction(identifier.getService(), identifier.getAction(), args);
}
----

This is an example of a `TypeKeysResolver` that returns all the possible `MetadataKey` available:

[source, java, linenums]
----
public class OperationTypeKeysResolver implements TypeKeysResolver {

  @Override
  public Set<MetadataKey> getKeys(MetadataContext context) throws MetadataResolvingException, ConnectionException {
    Set<MetadataKey> keys = new HashSet<>();
    for(String service : getServices()){
      MetadataKeyBuilder key = MetadataKeyBuilder.newKey(service);
      for(String action : getActions(service)){
        key.withChild(MetadataKeyBuilder.newKey(action).build());
      }
      keys.add(key.build());
    }
    return keys;
  }
}
----

[source, java, linenums]
----
public class OutputOperationTypeResolver implements OutputTypeResolver<ActionIdentifier>{

  @Override
  public MetadataType getOutputType(MetadataContext context, ActionIdentifier key)
     throws MetadataResolvingException, ConnectionException {
     // Resolve the output metadata using the ActionIdentifier
  }
}
----

[source, java, linenums]
----
public class InputOperationTypeResolver implements {

  @Override
  public MetadataType getInputMetadata(MetadataContext context, ActionIdentifier key)
    throws MetadataResolvingException, ConnectionException {
    // Resolve the input metadata using the ActionIdentifier
  }

}
----

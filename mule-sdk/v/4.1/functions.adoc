= Contributing Functions with Mule SDK
:keywords: mule, sdk, functions, function

DataWeave is the main Expression Language in Mule 4, and Mule SDK is also aligned with that view,
allowing you to contribute Functions to DataWeave from your Module's code in a similar fashion
of how you'd code a Mule <<operations#, Operation>>. Using custom Functions will allow yo to reuse code in a new way,
providing extra functionality in a single Module with very little overhead regarding how they are
declared compared to a Mule Operation.


== Declaring a Function

At Extension level, we'll use the `@ExpressionFunctions` annotation to reference the classes containing the
public methods representing the weave Functions. This method's code will be executed directly from
DataWeave scripts using their name as identifier:

[source, java, linenums]
----
@Extension(name = "Docs")
@ExpressionFunctions(DocsFunction.class)
public class DocsModule {

}
----

In the `DocsFunction` class we define the following method:

[source, java, linenums]
----
public Object xpath(@Optional(defaultValue = PAYLOAD) InputStream item,
                    String expression){
    try {
      return xPathFactory.newXPath().evaluate(expression, documentBuilder.parse(item));
    } catch (Exception e) {
      return null;
    }
  }
----

Our `xpath` Function can now be used from inside a weave script referencing it _inside our Module's namespace_.
In this example we'll be reading an XML and doing an XPath filter using our brand new `xpath` Function:

[source, xml, linenums]
----
<flow name="xpathFunctionUsingPayloadAsDefault">
    <file:read path="files/bookstore.xml"/>
    <set-payload value="#[Docs::xpath("/bookstore/book[price>35]/title")]"/>
</flow>
----

// == Restrictions

// TODO restrictions

=== Config-less and Connection-less

By definition, Functions are not allowed to depend on nor receive a particular
<<configs#, Configuration>> nor <<connections#, Connection>>.

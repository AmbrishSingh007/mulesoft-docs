= Multi-Level Metadata

Imagine the case where the end user will use an operation that invokes an action provided by a service. To know the metadata of what the action requires as arguments or what it returns, you will need to differentiate the service from the action to be executed. This will be your metadata key id. For these cases, the metadata key id does not need to be a single `String`. It can instead contain multiple parts
bundled in a complex parameter that holds the information needed to resolve the metadata.

== Implementing a Multi-Level Metadata Key

//TODO: RESUME COPYEDIT HERE
The different parameters of the metadata key must have an order in which they will have to be filled, starting on 1. Returning to the same example, the user will fill the
service field first and then which action to invoke. Then, the service parameter will
have the order 1 and the action parameter order 2.

All the parameters of the POJO representing the `MetadataKeyId` must be annotated with the @MetadataKeyPart annotation with
the order value set. These annotated fields must be of type `String`.

This is an example of how would this metadata key id class look like:

[source, java, linenums]
----
public class ActionIdentifier{

  @Parameter
  @MetadataKeyPart(order = 1) // <1>
  private String service;

  @Parameter
  @MetadataKeyPart(order = 2) // <1>
  private String action;

  @Override
  public String getService() {
    return service;
  }

  @Override
  public String getAction() {
    return action;
  }

  @Override
  public void setService(String service) {
    this.service = service;
  }

  @Override
  public void setAction(String action) {
    this.action = action;
  }
}
----

This is an example of an operation that uses a `MetadataKeyId` that is a complex type :

[source, java, linenums]
----
@OutputResolver(output = OutputOperationTypeResolver.class)
public Object invoke( @ParameterGroup(name = "Operation") @MetadataKeyId(OperationTypeKeysResolver.class) ActionIdentifier identifier,
                      @TypeResolver(InputOperationTypeResolver.class) Map<String, Object> args){
  return invokeAction(identifier.getService(), identifier.getAction(), args);
}
----

This is an example of a `TypeKeysResolver` that returns all the possible `MetadataKey` available:

[source, java, linenums]
----
public class OperationTypeKeysResolver implements TypeKeysResolver {

  @Override
  public Set<MetadataKey> getKeys(MetadataContext context) throws MetadataResolvingException, ConnectionException {
    Set<MetadataKey> keys = new HashSet<>();
    for(String service : getServices()){
      MetadataKeyBuilder key = MetadataKeyBuilder.newKey(service);
      for(String action : getActions(service)){
        key.withChild(MetadataKeyBuilder.newKey(action).build());
      }
      keys.add(key.build());
    }
    return keys;
  }
}
----

[source, java, linenums]
----
public class OutputOperationTypeResolver implements OutputTypeResolver<ActionIdentifier>{

  @Override
  public MetadataType getOutputType(MetadataContext context, ActionIdentifier key)
     throws MetadataResolvingException, ConnectionException {
     // Resolve the output metadata using the ActionIdentifier
  }
}
----

[source, java, linenums]
----
public class InputOperationTypeResolver implements {

  @Override
  public MetadataType getInputMetadata(MetadataContext context, ActionIdentifier key)
    throws MetadataResolvingException, ConnectionException {
    // Resolve the input metadata using the ActionIdentifier
  }

}
----

== Partial Fetching

*Available since version 1.1*

The process of getting all the possible `MetadataKey`s can potencially be very time
consuming. On the example of getting all the possible services and the actions of
each service, the information you are fetching may even be on another server.

Partial fetching enables you to resolve one level of the MetadataKey tree at the time.

The `getKeys` method from the `TypeKeysResolver` will not return the complete trees of
`MetadataKey`s but instead only the first level of each tree.

On this case, the ammount of information needed is greatly reduced, you only need to get
which are the possible services. Once a service is selected, you will need to provide the
next level on the `MetadataKey` tree.

To make this possible, your key resolver must implement `PartialTypeKeysResolver`

This is an example of how to implement it:

[source, java, linenums]
----
public class OperationTypeKeysResolver implements PartialTypeKeysResolver<ActionIdentifier> {

  @Override
  public Set<MetadataKey> getKeys(MetadataContext context) throws MetadataResolvingException, ConnectionException {
    Set<MetadataKey> keys = new HashSet<>();
    for(String service : getServices()){ // <1>
      MetadataKeyBuilder key = MetadataKeyBuilder.newKey(service);
      keys.add(key.build());
    }
    return keys;
  }

  @Override
  public MetadataKey resolveChilds(MetadataContext metadataContext, ServiceOperation key)
      throws MetadataResolvingException, ConnectionException {

    if(key.getService() == null){
      throw new MetadataResolvingException("Missing Service name. Cannot resolve Actions without a service",
                                         FailureCode.INVALID_METADATA_KEY);
    }

    MetadataKeyBuilder key = MetadataKeyBuilder.newKey(key.getService()); // <2>
    for(String action : getActions(key.getService())){
      key.withChild(MetadataKeyBuilder.newKey(action).build()); // <3>
    }
    return key;
  }

}
----

<1> Only the services are retrieved, the actions of a service will be retrieved on demand.
<2> Build a single `MetadataKey` tree with a new complete level of metadata, in this case, the
actions level.
<3> Add the actions of that service as children.

== Using User Input As Partial Level

*Available since version 1.1*

There may be cases where you can't hint the user a part of your MetadataKey, like when the
universe of options is too big (for example, it makes no sense to show all the classes in a classpath
in a dropdown), or when the starting point of the ID is a free input (for example, a query).

Take as example a `MetadataKeyId` that has a part that is a `String` representing a java class.
It would be both very time consuming to retrieve all the classes and complicated for the
user to have so many possibilities on a dropdown.

Because of this you can signal that a `MetadataKeyPart` will not be provided by the resolver and must be
inserted by the user. This is done by setting to false the `providedByKeyResolver` value on the `MetadataKeyPart`
annotation.

This is an example where the POJO representing the `MetadataKeyId`, represents a java
method:

[source, java, linenums]
----
public class MethodIdentifier{

  @Parameter
  @Alias("class")
  @MetadataKeyPart(order = 1, providedByKeyResolver = false) // <1>
  private String clazz;

  @Parameter
  @Alias("method")
  @MetadataKeyPart(order = 2)
  private String methodId;

  @Override
  public String getClazz() {
    return clazz;
  }

  @Override
  public String getMethodId() {
    return methodId;
  }

  @Override
  public void setClazz(String clazz) {
    this.clazz = clazz;
  }

  @Override
  public void setMethodId(String methodId) {
    this.methodId = methodId;
  }
}
----

<1> The clazz field will have to be inserted by the user without hints.

This also means that on this case the `getKeys` method cannot return all the
possible classes:

[source, java, linenums]
----
public class MethodTypeKeysResolver implements PartialTypeKeysResolver<MethodIdentifier> {

  @Override
  public Set<MetadataKey> getKeys(MetadataContext context) throws MetadataResolvingException, ConnectionException {
    return emptySet(); // <1>
  }

  @Override
  public MetadataKey resolveChilds(MetadataContext metadataContext, MethodIdentifier key)
      throws MetadataResolvingException, ConnectionException {

    if(key.getClazz() == null){
      throw new MetadataResolvingException("Missing Class name. Cannot resolve Methods without a target Class",
                                         FailureCode.INVALID_METADATA_KEY);
    }

    MetadataKeyBuilder key = MetadataKeyBuilder.newKey(key.getClazz()); // <2>
    for(String methodId : getMethodIds(key.getClazz())){
      key.withChild(MetadataKeyBuilder.newKey(methodId).build()); // <3>
    }
    return key;
  }

}
----

<1> return an empty set of `MetadataKey` since the user will provide this information.
<2> Build a single `MetadataKey` tree with a new complete level of metadata, in this case, the
methodIds level.
<3> Add the methodIds of that class as children.

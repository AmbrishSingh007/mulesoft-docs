= Multi Level Metadata

The metadata key id does not always need to be a `String` type. It can be a complex type that
holds the necessary information to resolve the metadata. Imagine the case where the user
will use an operation that invokes an action provided by a service. To know the metadata of what the action
require as arguments or what it returns, you will have to know which is the service and which is the action
to be executed, this will be your metadata key id.

== Implementing a Multi Level Metadata Key

The different parameters of the metadata key must have an order in which they will have
to be filled. This order will be a number starting on 1. Returning to the same example, the user
will fill the service field first and then which action to invoke. Then, the service
parameter will have the order 1 and the action parameter order 2.

All the parameters of the `MetadataKeyId` must be annotated with the @MetadataKeyPart annotation with
the order value set. These annotated fields must be of type `String`.

This is an example of how would this metadata key id class look like:

[source, java, linenums]
----
public class ActionIdentifier{

  @Parameter
  @MetadataKeyPart(order = 1) // <1>
  private String service;

  @Parameter
  @MetadataKeyPart(order = 2) // <1>
  private String action;

  public ActionIdentifier(){}

  public ActionIdentifier(String service, String action) {
    this.service = service;
    this.action = action;
  }

  @Override
  public String getService() {
    return service;
  }

  @Override
  public String getAction() {
    return action;
  }
}
----

This is an example of an operation that uses a `MetadataKeyId` that is a complex type :

[source, java, linenums]
----
@OutputResolver(output = OutputOperationTypeResolver.class)
public Object invoke( @ParameterGroup(name = "Operation") @MetadataKeyId(OperationTypeKeysResolver.class) ActionIdentifier identifier,
                      @TypeResolver(InputOperationTypeResolver.class) Map<String, String> args){
  return invokeAction(identifier.getService(), identifier.getAction(), args);
}
----

This is an example of a `TypeKeysResolver` that returns all the possible `MetadataKey` available:

[source, java, linenums]
----
public class OperationTypeKeysResolver implements TypeKeysResolver {

  @Override
  public Set<MetadataKey> getKeys(MetadataContext context) throws MetadataResolvingException, ConnectionException {
    Set<MetadataKey> keys = new HashSet<>();
    for(String service : getServices()){
      MetadataKeyBuilder key = MetadataKeyBuilder.newKey(service);
      for(String action : getActions(service)){
        key.withChild(MetadataKeyBuilder.newKey(action).build());
      }
      keys.add(key.build());
    }
    return keys;
  }
}
----

[source, java, linenums]
----
public class OutputOperationTypeResolver implements OutputTypeResolver<ActionIdentifier>{

  @Override
  public MetadataType getOutputType(MetadataContext context, ActionIdentifier key)
     throws MetadataResolvingException, ConnectionException {
     // Resolve the output metadata using the ActionIdentifier
  }
}
----

[source, java, linenums]
----
public class InputOperationTypeResolver implements {

  @Override
  public MetadataType getInputMetadata(MetadataContext context, ActionIdentifier key)
    throws MetadataResolvingException, ConnectionException {
    // Resolve the input metadata using the ActionIdentifier
  }

}
----

== Partial Fetching

*Available since version 1.1*

The process of getting all the possible `MetadataKey`s can potencially be very time
consuming. On the example of getting all the possible services and the actions of
each service, the information you are fetching may even be on another server.

Partial fetching enables you to resolve one level of the MetadataKey tree at the time.

The `getKeys` method from the `TypeKeysResolver` will not return the complete trees of
`MetadataKey`s but instead only the first level of each tree.

On this case, the ammount of information needed is greatly reduced, you only need to get
which are the possible services. Once a service is selected, you will need to provide the
next level on the `MetadataKey` tree.

To make this possible, your key resolver must implement `PartialTypeKeysResolver`

This is an example of how to implement it:

[source, java, linenums]
----
public class OperationTypeKeysResolver implements PartialTypeKeysResolver<ActionIdentifier> {

  @Override
  public Set<MetadataKey> getKeys(MetadataContext context) throws MetadataResolvingException, ConnectionException {
    Set<MetadataKey> keys = new HashSet<>();
    for(String service : getServices()){ // <1>
      MetadataKeyBuilder key = MetadataKeyBuilder.newKey(service);
      keys.add(key.build());
    }
    return keys;
  }

  @Override
  public MetadataKey resolveChilds(MetadataContext metadataContext, ServiceOperation key)
      throws MetadataResolvingException, ConnectionException {

    if(key.getService() == null){
      throw new MetadataResolvingException("Missing Service name. Cannot resolve Actions without a service",
                                         FailureCode.INVALID_METADATA_KEY);
    }

    MetadataKeyBuilder key = MetadataKeyBuilder.newKey(key.getService()); <2>
    for(String action : getActions(key.getService())){
      key.withChild(MetadataKeyBuilder.newKey(action).build());
    }
    return key;
  }

}
----

<1> Only the services are retrieved, the actions of a service will be retrieved on demand.
<2> Build a single `MetadataKey` tree with a new complete level of metadata, in this case, the
actions level.


== Restricted Partial Fetching

*Available since version 1.1*

There are parts of the `MetadataKey` that you may not want to hint the user. This may be
because the universe of possibilities it too big, or because it is a custom field. Take as example
a `MetadataKey` that has a part that is a `String` representing a java class. It would be both very time
consuming to retrieve all the classes and complicated for the user to have so many possibilities on a
dropdown.

Because of this you can signal that a `MetadataKeyPart` will not be provided by the resolver and must be
inserted by the user. This is done by setting to false the `providedByKeyResolver` value on the `MetadataKeyPart`
annotation.

This is an example where the service name is not given by the resolver :

[source, java, linenums]
----
public class ActionIdentifier{

  @Parameter
  @MetadataKeyPart(order = 1, providedByKeyResolver = false) // <1>
  private String service;

  @Parameter
  @MetadataKeyPart(order = 2)
  private String action;

  public ActionIdentifier(){}

  public ActionIdentifier(String service, String action) {
    this.service = service;
    this.action = action;
  }

  @Override
  public String getService() {
    return service;
  }

  @Override
  public String getAction() {
    return action;
  }
}
----

<1> The service field will have to be inserted by the user without hints.

This also means that on this case the `getKeys` method does not need to return all the
possible services:

[source, java, linenums]
----
public class OperationTypeKeysResolver implements PartialTypeKeysResolver<ActionIdentifier> {

  @Override
  public Set<MetadataKey> getKeys(MetadataContext context) throws MetadataResolvingException, ConnectionException {
    return emptySet(); // <1>
  }

  @Override
  public MetadataKey resolveChilds(MetadataContext metadataContext, ServiceOperation key)
      throws MetadataResolvingException, ConnectionException {

    if(key.getService() == null){
      throw new MetadataResolvingException("Missing Service name. Cannot resolve Actions without a service",
                                         FailureCode.INVALID_METADATA_KEY);
    }

    MetadataKeyBuilder key = MetadataKeyBuilder.newKey(key.getService()); <2>
    for(String action : getActions(key.getService())){
      key.withChild(MetadataKeyBuilder.newKey(action).build());
    }
    return key;
  }

}
----

<1> return an empty set of `MetadataKey` since the user will provide this information.

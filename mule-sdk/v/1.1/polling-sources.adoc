= Polling Sources
*Available since version 1.1*

Polling Sources are sources that, instead of being triggered by an external action, poll
data items periodically depending on a `scheduling strategy` that determines the frequency at
which the poll occurs. Every item is dispatched to the flow as a single `Message`.

== Creating a Polling Source

To create a Polling Source, first you need to add the `Source` class to the
`@Sources` annotation on the extension class, just like regular Sources. For a Source
to behave as a `PollingSource`, instead of extending the class `Source<T,A>`, the class needs
to extend from `PollingSource<T, A>`.

By extending from `PollingSource<T, A>` you will need to implement the methods `poll` and
`onRejectedItem`.

* `poll` is responsible for obtaining the items to be dispatched and communicating with them through the `pollContext`
using the `accept` method.

- `onRejectedItem` is called when one of the items dispatched was rejected (for example, by watermarking,
idempotency, server overload, and so on). This method will be called to release any resources associated 
with the result set for the `PollItem`.

Here is an example of a simplified version of the directory listener for the FTP connector:

[source, java, linenums]
----
public class FtpDirectoryListener extends PollingSource<InputStream, FtpFileAttributes> {
  @Override
  public void poll(PollContext<InputStream, FtpFileAttributes> pollContext) {
    if (pollContext.isSourceStopping()) {
      return;
    }
    List<FtpFileAttributes> attributesList = listFiles().getAttributes();

    for (FtpFileAttributes attributes : attributesList) {
      if(pollContext.isSourceStopping()){  // <1>
        break;
      }
      processFile(attributesList, pollContext)
    }
  }

  @Override
  public void onRejectedItem(Result<InputStream, FtpFileAttributes> result, SourceCallbackContext callbackContext) {
    closeQuietly(result.getOutput());
  }

}
----

<1> Note that the `pollContext` provides information on whether the Source is stopping, and this is taken into
account before any time consuming task.

== Using the Polling Context

There are some things that are missing from the last example that are done in the `processFile` method. These
are the steps required to dispatch the messages to the flow. This is done using the `PollContext`.

The `accept` method from the `PollContext` is in charge of dispatching the polled items into the flow. It
receives as parameter a `Consumer<PollItem>`

This example shows what `processFile` method from the previous example is doing:

[source, java, linenums]
----
private void processFile(FtpFileAttributes attributes, PollContext<InputStream, FtpFileAttributes> pollContext) {
  PollItemStatus status = pollContext.accept(item -> {     // <1>
    SourceCallbackContext ctx = item.getSourceCallbackContext();   // <2>
    FtpFileSystem fileSystem = openConnection();
    ctx.bindConnection(fileSystem);   // <3>
    Result<InputStream, FtpFileAttributes> result = fileSystem.read(config, attributes.getPath(), false);
    item.setResult(result); //  <4>
    item.setId(attributes.getPath());  // <5>
    item.setWatermark(attributes.getTimestamp());  // <6>
  });
}
----

<1> The `accept` method dispatches a message to the flow. This returns what happened to the item.
<2> Get the callback context.
<3> Bind the connection to the context so that it can be retrieved later.
<4> Set the message that will be dispatched to the flow.
<5> Set an ID to the item so that idempotency can be checked.
<6> Set the watermark to the item so that watermark can be checked.

=== PollItemStatus

After calling the `accept` method, you will get a `PollItemStatus`. This is an `Enum` that
can take the following values:

* ACCEPTED:  The item was accepted and has been scheduled for execution.
* FILTERED_BY_WATERMARK:  The item was rejected because watermarking was enabled, so it was filtered.
* ALREADY_IN_PROCESS: The item was rejected because idempotency was enabled and another thread or node is already processing this item.
* SOURCE_STOPPING: The item was rejected because the source has received the stop signal.

=== Idempotency

Idempotency prevents items from getting polled twice. The SDK ensures that
no other thread or cluster node is processing an item of the same ID, providing processing idempotency.
No two items with the same ID will be processed at the same time. If a node polls an item with the ID
of an item that is being processed, the item will be dropped, and the `onRejectedItem` method will be called.

=== Watermarking

What do you do when you are polling an incremental source of data and you only want the new data?
Should you manually divide the new data from the old data on each call? No, by using watermarking you can
solve this problem easily.

By setting an incrementing value to the item's watermark, every other poll will drop and
call `onRejectedItem` on any of the item's watermark values that are lower than the current watermark value.
In the example shown before, the watermark chosen is the timestamp of the file.

What criteria does the SDK use to compare watermarks?

If the watermarks that are used implement `Comparable`, the natural order of those values will be used. There
is no need to set a criteria.

What if the watermark values do not implement `Comparable`, or what if I want to use another criteria
that is not the natural order?

You can simply set a `Comparator` to the `PollContext` by calling its method `setWatermarkComparator`.

== How to use Polling Sources in a Flow

The SDK will automatically adds a `scheduling strategy` parameter, and the runtime will use that strategy
to automatically schedule executions of the `poll` method.

Here is an example that uses the FTP directory listener polling source:

[source, xml, linenums]
----
<ftp:listener config-ref="config" directory="path/" autoDelete="false" watermarkEnabled="true">
  <scheduling-strategy>
    <fixed-frequency startDelay="40000" frequency="1000" timeUnit="MILLISECONDS"/>
  </scheduling-strategy>
</ftp:listener>
----

= Stereotypes

:keywords: stereotype, mule, sdk, types

An stereotype is a loose way to typify a Component. By assigning an stereotype to a Component
you are not implying that it has any specific return type or structure, but just saying that it hold something
in common with the rest of the components in the same stereotype. You can use this stereotypes to enforce
certain parameter to be of a specific stereotype.

== Stereotype Annotation

To assign a stereotype to a Component you must use the `@Stereotype` annotation along with
a `StereotypeDefinition` class.

This annotation can be used either at method level, thus affecting only that particular
operation, or at class level, assigning the given Stereotype to all the operations defined in that class.

A component can only belong to one Stereotype, this means that if the `@Stereotype` annotation is used on a
component there cannot be other annotations that assign a Stereotype to the operation.

For example, the `@Validator` annotation that is used to signal that an operation does not change
the message and only performs some kind of validation assigns a Stereotypes to the operation
automatically.

This is an example of how to use this annotation on Operations:

[source, java, linenums]
----
@Stereotype(JenkinsStereotypeDefinition.class)
public final class CommonJenkinsOperations {


  public void triggerBuild(String name, Map<String,String> arguments)
      throws Exception {
      // ...
  }

  public void createJobs(String name, Map<String,String> arguments)
      throws Exception {
      // ...
  }

  public Result<JenkinsInformation , JenkinsAttributes> ActiveJobs()
      throws Exception {
      // ...
  }
}

----

In this case, all the Operations in the class `CommonJenkinsOperations` will be of the
Stereotype defined in `JenkinsStereotypeDefinition`

== StereotypeDefinition

This interface is in charge of providing the Stereotype name, namespace and the
Stereotype parent. By default the namespace is assigned to the extension's namespace.

Stereotypes have a hierarchy, by default they do not extend from another Stereotype unless specified.

This is an example of how to define a `StereotypeDefinition`:

[source, java, linenums]
----
public final class JenkinsStereotypeDefinition extends MuleStereotypeDefinition { // <1>

  @Override
  public String getName() {
    return "JENKINS_OPERATION";
  }

  @Override
  public Optional<StereotypeDefinition> getParent() {
    return Optional.of(PROCESSOR_DEFINITION); <2>
  }

}
----

<1> The JenkinsStereotypeDefinition class extends from a `StereotypeDefinition` which has knows about several
`StereotypeDefinition` like `PROCESSOR_DEFINITION`.
<2> Selects `PROCESSOR_DEFINITION` which is a `StereotypeDefinition` defined in `MuleStereotypeDefinition`
as this `StereotypeDefinition`'s parent.

== AllowedStereotypes Annotation on Parameters

This annotation's purpose is to indicate which are the possible `StereotypeDefinition` that
are accepted for a parameter. The value of this annotation is a single value or array of `StereotypeDefinition`.
It can only be applied to parameters of type `Chain` or `Route`.

This is an example of how to enforce a certain Stereotype as a parameter:

[source, java, linenums]
----
public class JenkinsScope {

  private static final Logger logger = getLogger(JenkinsScope.class);

  public void jenkinsGroupExecution(@AllowedStereotypes(JenkinsStereotypeDefinition.class) Chain operations,
                  CompletionCallback<Void, Void> callback)
      throws Exception {

    LOGGER.debug("Invoking Jenkins Operations.")
    operations.process(
      result -> {
        // Log information about the execution of the operations
        callback.success(result);
      },
      (error, previous) -> {
        LOGGER.error(error.getMessage());
        callback.error(error);
    });

  }

}
----

The `Chain` that is received can only contain operations with the Stereotype defined in `JenkinsStereotypeDefinition`
class.

== Configuration Reference

Every Configuration has a unique stereotype assigned automatically, this stereotype bears the
following characteristics:

* Both the name and the namespace are uppercased and words are separated by underscores.

* The namespace is the namespace of the extension, for example : "HTTP" for the HTTP Connector
 or "JMS" for the JMS Connector.

* The name is the name of the configuration, for example: the "requestConfig" Configuration's stereotype
name will be "REQUEST_CONFIG"

This default stereotype can be overwritten using the `@Stereotype` annotation.

We can use this stereotype to restrict a `String` parameter to a name a of certain type of
Configuration through the usage of the `@ConfigReference` annotation. This annotation requires
the name and namespace of the Configuration stereotype.

A usage example of this feature would be, developing an extension that uses the HttpService, which
requires a HttpRequesterConfig for its use. Then with the usage of the Extension Client, the
HttpService will use the actual Configuration.

For example, if the HTTP Connector has this `HttpRequesterConfig` declared:

[source, java, linenums]
----
@Configuration(name = "requestConfig")
@ConnectionProviders(HttpRequesterProvider.class)
@Operations({HttpRequestOperations.class})
public class HttpRequesterConfig {
  // Parameters and getters for the Configuration
}
----


And the Web Service Consumer Connector is defined like this:

[source, java, linenums]
----
@ErrorTypes(SoapErrors.class)
@Operations(ConsumeOperation.class)
@ConnectionProviders(SoapClientConnectionProvider.class) // <1>
@SubTypeMapping(baseType = CustomTransportConfiguration.class, subTypes = CustomHttpTransportConfiguration.class)
@Extension(name = "Web Service Consumer")
@Xml(prefix = "wsc")
public class WebServiceConsumer {
}
----
<1> This ConnectionProvider holds a parameter that is using the `@ConfigReference` annotation. Note
that since the connector does not declare any configuration, the default `config` will be used.


This is part of the declaration of the ConnectionProvider:

[source, java, linenums]
----
public class SoapClientConnectionProvider implements CachedConnectionProvider<SoapClientWrapper> {
  // ...
  @Inject
  private HttpService httpService;
  // ...
  @Placement(tab = "Transport")
  @Parameter
  @Optional
  @Expression(NOT_SUPPORTED)
  @DisplayName("Transport Configuration")
  private CustomTransportConfiguration customTransportConfiguration;
  // ...
}
----

Here is where the `@ConfigReference` annotation is used:

[source, java, linenums]
----
@Alias("http-transport-configuration")
public class CustomHttpTransportConfiguration implements CustomTransportConfiguration {

  @ConfigReference(namespace = "HTTP", name = "REQUEST_CONFIG") // <1>
  @Parameter
  private String requesterConfig;

  @Override
  public MessageDispatcher buildDispatcher(ExtensionsClient client) {
    return new HttpConfigBasedMessageDispatcher(requesterConfig, client); // <2>
  }

  @Override
  public TransportResourceLocator resourceLocator(ExtensionsClient client) {
    return new HttpResourceLocator(requesterConfig, client); // <2>
  }
----

<1> This Sting parameter `requesterConfig` must take the value of the name of a `HttpRequesterConfig`.
<2> The name of the configuration is used along with the `ExtensionsClient`

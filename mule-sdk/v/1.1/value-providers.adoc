= Value Providers
:keywords: mule, sdk, value provider, dynamic values

When developing a connector, you can let the end user select a parameter
from a set of values. This makes it easier for the user to know what to configure, and you can be sure that the configured values will be correct.

You can provide this functionality for known values by using a <<java_enum, Java Enum>> as a parameter. The SDK automatically takes all the values from the Enum so they can be provided as a combo-selector in the UI.

To include values that are not known, such as custom values, you should use <<value_providers, Value Providers>>, instead.

[[java_enum]]
== Java Enum

Assume that you are developing a connector for a Content Publishing Service that can publish content with these roles:

* `ADMIN`
* `READER`
* `WRITER`

To provide these roles, you simply create a `UserRole` Enum and expose it as a parameter of the `publishAs` operation, for example:

.Example: Java Enum the Defines Known Roles
[source, Java, linenums]
----
public enum UserRole {
    ADMIN, READER, WRITER
}
----

The operation in the next example lets the user publish content using a certain `UserRole`.

[source, Java, linenums]
----
public void publishAs(@Content Object content, UserRole roleEnum){
    System.out.println("Publishing " + content + " with Role: " + roleEnum);
}
----

This solution is easy and effective, but it carries several limitations and problems:

* Required to set a custom value: Because the parameter is based on a Enum, you cannot define a custom value.
* The values are defined statically: You cannot change the values depending on a connection or configuration.
* Java Enums have naming restrictions: You cannot have an Enum value starting with a Number or special characters.

Returning to the `UserRole` example:

If the service to which you are connecting can be configure with custom roles, you will not be able to continue using the `UserRole` Enum because it will limit the connector's capabilities.

If you do not want to lose the drop-down list of known User Roles, you can use <<value_providers, Value Providers>> to define dynamic values.

[[value_providers]]
== Value Providers

Value Providers let you provide values in a dynamic and smart way for any parameter in any component of a connector: link:operations[Operations], link:sources[Sources], link:configs[Configurations], link:connections[Connection Providers], scopes, and so on.

[[StaticUserRoleValueProvider]]
=== To Implement Value Providers

This example produces the same behavior as the Enum solution above, but it provides the benefit of an open set of values.

. Create a Java Class implementing `ValueProvider`.
+
When implementing this interface, you must implement the `resolve()` method, which returns a set of <<value-structure, values>>.
+
[source, Java, linenums]
----
public class StaticUserRoleValueProvider implements ValueProvider {

    @Override
    public Set<Value> resolve() {
        return ValueBuilder.getValuesFor("ADMIN", "READER", "WRITER");
    }
}
----
+
. Mark the parameter that requires dynamic values with the `@OfValues()` annotation.
+
`@OfValues` requires a `ValueProvider` implementation that is bound to the parameter, for example:
+
[source, Java, linenums]
----
public void publishAs(@Content Object content,
@OfValues(StaticUserRoleValueProvider.class) String userRole){ //<1>
    System.out.println("Publishing " + content + " with Role: " + userRole);
}
----
+
. Now, you can use it in Studio or Design Center to start retrieving values.
+
image:value_providers/value-provider-static.gif[align="center"]

=== Value Providers with Connections or Configurations

Value Providers can receive connections and configurations, so you can resolve values based on the current connection and configuration.

IMPORTANT: You cannot inject connections and configurations into Value
Providers that are located in connection and configuration parameters.

==== Receiving a Connection or Configuration

You use the `@Connection` and `@UseConfig` annotations to declare the use of a connections and configurations inside a Value Provider. To work, a Value Provider that uses the annotations depends on a _valid_ configuration or connection. The SDK ensures that the resolving logic will not be executed unless the connection and configuration are valid.

[source, Java, linenums]
----
public class ConnectedValueProvider implements ValueProvider {

  @Connection
  ServiceConnection connection;

  @UseConfig
  ServiceConfig config;

  @Override
  public Set<Value> resolve() throws ValueResolvingException {
    //Do whatever is required with the connection or config
    List<String> result = connection.retrieveInfo();
    return ValueBuilder.getValuesFor(result);
  }
}
----

WARNING: The injected connections and configurations must be of type that is compatible with those defined in the operation or source where the Value Provider
is referenced.

=== Example 2: Connected Value Provider Use Case

//TODO: USE OF "communicate"? Is there another word we can use?

In the previous Roles example above, the service could define custom roles, but it was not possible for the connector to communicate those roles.

Now that the Value Provider can resolve values, it is possible to communicate these roles because the connection can be used to fetch the available roles and communicate them through the Value Provider:

[source, Java, linenums]
----
public class UserRoleValueProvider implements ValueProvider {

  @Connection
  ServiceConnection connection;

  @Override
  public Set<Value> resolve() throws ValueResolvingException {
    return ValueBuilder.getValuesFor(connection.getAvailableRoles());
  }
}
----

=== Value Providers that Depend on Other Parameters

In addition to injecting connections and configurations, Value Providers can  depend on other parameters of the _same context_. The SDK ensures that the Value Provider resolving logic will no be executed until the required parameters are configured.

The words "_same context_" mean that if the Value Provider is used in a component, the required parameter must exist in that component. For example, if the configuration `FancyConfig` with a Value Provider in the parameter `dynamicParam` requires the value of the parameter `aConfigParam`, `aConfigParam` must exist in the `FancyConfig` configuration.

CAUTION: The use of expressions in the required parameters might disable the
execution of the Value Provider due to the impossibility of resolving the expression without an active event.

==== Declaring required parameters

To declare parameter that will be required to execute the resolving logic, in
the same way as Connection and Configurations, is required to use the already know
annotation of `@Parameter` in a field of the Value Provider with the *same type
and name* of the required parameter.


.Example External parameters: Operation declaring two params, one with a value provider
[source, Java, linenums]
----
public void operationWithValueProvider(String requiredParam, @OfValues(ValueProviderWithRequiredParams.class) String dynamicParam){

}
----

.Example External parameters: Value provider requiring the `requiredParam` parameter.
[source, Java, linenums]
----
public class ValueProviderWithRequiredParams implements ValueProvider {

    @Parameter
    String requiredParam;

    @Override
    public Set<Value> resolve() {
      return ValuesBuilder.getValuesFor(param);
    }
}
----
=====  What happens is the required parameter is not configured?

If the parameter is defined as required in the component and was not configured
by the Mule developer, the value provider won't never be executed.
Otherwise, if the parameter is defined as Optional, the Value Provider will be
executed with a `Null` value and the nullability should be handled by the
connector developer.

===== Example 3: Value Provider with context parameters

Consider the case where you want to have a Date Picker, just Day and Month,
both can be easily represented with two Enums, but there is a problem, not all
months have the same amount of days, this could let the user configure invalid
dates, how we could fix this usage problem?

1. Define the operation to expose a Date Picker +
The operation receives two parameters, an `monthEnum` which statically communicates all the
available months and a `day`, which is used to communicate the Day of the month.
+
.Publish On Date Operation
[source, Java, linenums]
----
public void publishOnDate(Month monthEnum, @OfValues(DayValueProvider.class) String day) {
}
----

2. Defining the Month Enum +
The `Month` contains all the available months and knows the amount of days in each month.
+
.MonthEnum Enum
[source, Java, linenums]
----
public enum Month {

    JANUARY(31), FEBRUARY(28), MARCH(31), APRIL(30), MAY(31), JUNE(30),
    JULY(31), AUGUST(31), SEPTEMBER(30), OCTOBER(31), NOVEMBER(30), DECEMBER(31);

    private int dayCount;

    MonthEnum(int i) {
        dayCount = i;
    }

    public int getDayCount() {
        return dayCount;
    }
}
----

3. Create Value Provider which consumes the selected Month
+
This Value Provider which will provide dynamically depending in the selected
month all the available days in that Month.
The `DayValueProvider` communicates that requires the parameter `monthEnum` to
work
+
[source, Java, linenums]
----
public class DayValueProvider implements ValueProvider {

    @Parameter
    Month monthEnum; //<1>

    @Override
    public Set<Value> resolve() {
      return ValueBuilder.getValuesFor(getNumbersFrom(1, monthEnum.getDayCount())
              .stream()
              .map(num -> String.format("%02d", num)));
    }

    List<Integer> getNumbersFrom(int init, int end){
        List<Integer> numbers = new ArrayList<>(end - init);
        for (int i = init; i <= end; i++) {
            numbers.add(i);
        }
        return numbers;
    }
}
----

4. *Result!* As can be seeing in the below animation, the `Day` selector
gets populated dynamically depending in the `Month enum` parameter value.

+
image:value_providers/value-provider-months.gif[align="center"]

[[value-structure]]
==== Value Structure

Value Providers return a set of Values. A `Value` is a simple structure composed of these properties:

* `id` : A unique identifier for this value. This is required.
* `displayName`: A name that will be displayed in the UI. This is optional. By  default, the ID will be used as the Display Name.

==== How to create a Value

There is a unique way to create values by using `ValueBuilder`.

[source, Java, linenums]
----

ValueBuilder adminValueBuilder = ValueBuilder.newValue("ADMIN_USR_ROLE"); //<1>
adminValueBuilder.withDisplayName("Admin"); //<2>
Value adminValue = newValue.build(); //<3>

----

<1> You must create the `ValueBuilder` with the ID of the `Value`.
<2> Optionally, you can enrich the value with a Display Name.
<3> Build the builder to return a `Value` instance.

== ValueBuilder Utils

`ValueBuilder` provides utilities to make it easier to create values for
certain cases.

If you have a `List<String>`, `String[]`, `Stream<String>`, or `Map<String, String>` with values that need to be transformed to Values, the easiest way to make this transformation is to use `getValuesFor()`.

[source, Java, linenums]
----
// Array Case
Set<Value> arrayCase = ValueBuilder.getValuesFor("Admin", "Writer");

// List Case
List<String> valueList = new ArrayList<>();
valueList.add("Admin");
valueList.add("Writer");
Set<Value> listCase = ValueBuilder.getValuesFor(valueList);

// Stream Case
Set<Value> streamCase = ValueBuilder.getValuesFor(valueList.stream());

// Map Case
// The Key will be considered as ID and the Value as Display Name
Map<String, String> valueMap = new HashMap<>();
valueMap.put("ADMIN_USR_ROLE", "Admin");
valueMap.put("WRITER_USR_ROLE") "Writer");
Set<Value> mapCase = ValueBuilder.getValuesFor(futureValues);
----

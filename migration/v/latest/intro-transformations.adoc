= Introduction to Mule 4: Transformations and Streaming

The way to think about data in Mule 4 is fundamentally different in Mule 3. In Mule 3, you
often need to know about the underlying Java types, how to manage InputStreams, whether
a payload is larger-than-memory, and how to convert data into Java objects so they can be accessed by MEL.

For Mule 4, these best practices are recommended:

* Avoid unnecessary conversions to Java data types, and work with data directly.
* Let the runtime handle stream memory management for you.
* Do not convert binary data types to `String`, `byte[]`, or `InputStream` unless you are performing a direct integration with custom Java code.

== Automatic Memory Management

link:intro-expressions[Introduction to Mule 4: DataWeave Expression Language] showed how to work with data directly using DataWeave. The reason you no longer have to convert your data to Java objects first is because Mule now takes care of data streams for you automatically. This change greatly simplifies working with data in the runtime because:

* Data can be read multiple times or accessed randomly using the DataWeave expression language, without side effects.
* Data can be sent to multiple places, without the need to cache that data in memory first.
* You can transparently access larger-than-memory data.

[[streaming_strategy]]
Streams can be controlled through a streaming strategy configuration on the connector operations. You can configure it to be
automatic, in-memory only, or stored on disk only.
[source,xml,linenums]
----
<file:read path="bigFile.json">
  <repeatable-in-memory-stream initialBufferSize="512"
                               bufferSizeIncrement="256"
                               maxBufferSize="2048"
                               bufferUnit="KB"/>
</file:read>
----

== Data Types and Object to String/Byte/InputStream Transformers

Because Mule is now managing the data streams for you, data access becomes simpler. You do not
need to be concerned with the underlying Java representation of that type.
Whether it is a `byte[]`, `InputStream`, `String`, or some other format.

A common pattern that was observed in Mule 3 applications, is that users would convert things to strings to log them or
send them through some transport.

[source,xml,linenums]
----
<http:listener ... /> <!-- set the payload to an InputStream -->
<object-to-string/> <!-- convert it to a String -->
<logger message="#[payload]"/> <!-- log the String -->
<jms:outbound-endoint .../> <!-- send the String -->
----

In Mule 4, you can simply log or send the data without worrying about the underlying type. Instead of thinking about the `InputStream`, you can just think
about the payload as binary data. Or, if the content type is known, you can think about it directly as JSON, XML,
or whatever data type corresponds to the content type.

[source,xml,linenums]
----
<http:listener ... /> <!-- payload is JSON document -->
<logger message="#[payload]"/> <!-- log the JSON document -->
<jms:outbound-endoint .../> <!-- send the JSON document -->
----

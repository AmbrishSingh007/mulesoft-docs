// sme: MG, author: sduke?
= Migrating the Database Connector

// Explain generally how and why things changed between Mule 3 and Mule 4.
The Database connector for Mule 4 can connect to any relational database engine. Here are the main changes for Mule 4:

* Operations:
 ** All database processes (such as Select, Insert, Update, Delete, and others) have been refactored into separate operations. This change includes bulk functionality (through Bulk Insert, Bulk Update, and Bulk Delete operations) so that database operations no longer change their behavior depending on the received payload.
 ** Use of DataWeave: Insert and Update operations support DataWeave transformations. You can construct the data sets that insert or update the database without message side effects, and you no longer use message enrichers.
* You can perform dynamic and static queries in similar ways.
* You can embed DataWeave transformations inside the Insert and Update operations so that you can construct the data sets you want to send to the database without having a side effect on the message or needing to use enrichers.
* The Mule streaming framework is automatically configured for your operations. You can execute a select statement and process the results asynchronously without worrying about leaking connections.

////
|===
| Operations in Mule 3 | Changes in Mule 4

| Bulk Execute (`db:bulk-execute`) | Bulk Delete (`db:bulk-delete`), Bulk Insert (`db:bulk-insert`), Bulk Update (`db:bulk-update`)

| DDL operations such as CREATE, ALTER, etc. | TODO?
|===
////

== What's Covered Here?

* <<database_configuration>>
* <<database_operation_select>>
* <<database_dynamic_queries>>
* <<database_streaming>>
* <<database_insert_update_delete>>
* <<database_operation_bulk>>

[[database_configuration]]
== Database Configuration

// TODO: EXPLAIN CONFIG CHANGES?
The connector for Mule 4 continues to support Derby, Microsoft SQL Server, MySQL, Oracle, and generic database configurations. It also supports a Data Source Reference connection. However, the XML for configuring them has changed significantly.

Notice that `<database:derby-config />` in Mule 3 changes to `<db:config />` in Mule 4. The attribute for setting the URL to the database changes from  `url` to `database` in Mule 4. The `<db:derby-connection />` element is new in Mule 4.

.Mule 3 Example: Configurations
[source,xml]
----
<database:derby-config name="DerbyConfig"
 url="derbydatabase.com/MydatabaseTest"
 doc:name="Derby Configuration"/>
----

.Mule 4 Example: Derby Configuration
[source,xml]
----
<db:config name="DerbyConfig" doc:name="Database Config"
 doc:id="280a5579-5490-4773-a36c-5e824def2370" >
		<db:derby-connection database="derbydatabase.com/MydatabaseTest" />
	</db:config>
----

Additional `<db:derby-connection />` settings (XML attributes) that are specific to Derby are available:

* `create="true|false"`: Whether to create the database if it does not exist.
* `subsubProtocol="classpath"`: Type of SubsubProtocol to be used by Derby. The available options are `directory`, `memory`, `classpath` and `jar`.

=== Connector Configuration Details

Most database connection configurations are set under the same element in Mule. An exception is the Data Source Reference Connection.

* `<db:config />` is the top-level element for these configurations:
 ** Derby ()
 ** Microsoft SQL Server
 ** MySql
 ** Oracle
 ** Generic (`<db:config />`)
* `<db:data-source-connection />` is the top-level element for this configuration:
 ** Data Source Reference Connection

These additional setting can be nested under all database connection configurations in Mule 4:

* Column types (`<db:column-types/>`) for non-standard column types.
* Pooling profile (`<db:pooling-profile/>`) for database connection pooling.
* Reconnection strategies (`<reconnection/>`).
 ** Fail deployment when test connection fails (`failsDeployment="true"`).
* Expiration policy (`<expiration-policy/>`) for idle configuration instances.

.Mule 4 Example: Data Source Reference
[source,xml]
----
<db:data-source-connection dataSourceRef="data_source_ref_here" >
  <reconnection failsDeployment="true">
    <reconnect frequency="4000" count="4"/>
  </reconnection>
  <db:column-types >
    <db:column-type id="124"
     typeName="column_type"
     className="class_name" />
  </db:column-types>
  <db:pooling-profile maxPoolSize="6" minPoolSize="1"
   acquireIncrement="2" preparedStatementCacheSize="6"
   maxWait="1" maxWaitUnit="MINUTES" />
</db:data-source-connection>
----

This setting is unique to Data Source Reference:

* `dataSourceRef="my_ref_here"`: Reference to a JDBC DataSource object. This object is typically created using Spring. When using XA transactions, an XADataSource object must be provided.

.Mule 4 Example: Generic
[source,xml]
----
<db:config name="generic_connection" doc:name="Database Config"
 doc:id="a328feea-1b5e-4a14-b7dd-d457a76d56b5" >
  <reconnection />
  <db:column-types />
  <db:pooling-profile />
  <db:generic-connection url="url_here" driverClassName="driver_class_name_here" transactionIsolation="READ_COMMITTED" useXaTransactions="true"/>
  <expiration-policy maxIdleTime="30" timeUnit="SECONDS"/>
</db:config>
----

These setting are unique to a Generic database:

* `url="url_here"` for the JDBC URL to be used to connect to the database.
* `driverClassName="driver_class_name_here"` for the fully-qualified name of the database driver class.

These settings are available for Generic, Microsoft SQL Server, and Oracle connections:
* Transactions (for Generic, ) for the transaction isolation level to set on the driver when connecting the database.
 ** NOT_CONFIGURED (Default)
 ** READ_COMMITTED (`transactionIsolation="READ_COMMITTED"`)
 ** READ_UNCOMMITTED (`transactionIsolation="READ_UNCOMMITTED"`)
 ** REPEATABLE_READ (`transactionIsolation="REPEATABLE_READ"`)
 ** SERIALIZABLE (`transactionIsolation="SERIALIZABLE"`)
 ** Use XA Transactions (`useXaTransactions="true|false"`)

.Mule 4 Example: Microsoft SQL Server
[source,xml]
----
<db:config name="Microsoft_SQL_Server" doc:name="Database Config"
 doc:id="774cc10a-802c-43b1-aa90-7fca9a22fa83" >
  <db:mssql-connection host="my_host" user="myuser"
   password="mypassword" databaseName="mydatabase" >
    <reconnection />
    <db:column-types />
    <db:pooling-profile />
  </db:mssql-connection>
</db:config>
----

Microsoft SQL Server, MySql, Oracle configurations require a driver. T

.Example: Maven dependency setting for a Microsoft SQL Server driver
[source,xml]
----
<dependency>
  <groupId>com.microsoft.sqlserver</groupId>
  <artifactId>mssql-jdbc</artifactId>
  <version>6.2.2.jre8</version>
  <type>jar</type>
</dependency>
----

.Mule 4 Example: MySql
[source,xml]
----
<db:config name="MySQ" doc:name="Database Config"
 doc:id="27dba545-03f3-467a-8ccc-88dbbfca6b74" >
  <db:my-sql-connection host="myhost" user="myuser"
   password="mypassword" database="mydatabase" >
    <reconnection />
    <db:column-types />
    <db:pooling-profile />
  </db:my-sql-connection>
</db:config>
----

.Mule 4 Example: Oracle JDBC Database
[source,xml]
----
<db:config name="Oracle_Connection" doc:name="Database Config"
 doc:id="c307c37f-b02f-4f10-b0dd-6f1ea42feab2" >
  <db:oracle-connection host="myhost" user="myuser"
   password="mypassword" instance="myinstance" >
    <reconnection />
    <db:column-types />
    <db:pooling-profile />
  </db:oracle-connection>
  <expiration-policy />
</db:config>
----

Note that only some database connections provide these settings:

* Connection properties (MySQL, Microsoft SQL Server only) for a list of custom key-value connection properties for the configuration.
 ** None (Default)
 ** Expression
 ** Inline
* Port (`port`) for non-standard ports. Otherwise, the connector uses the standard port by default.

== Database Connector Operations

In Mule 4, all database connector operations have a configurable display name, and all require reference to a connector configuration. They also provide a common set of settings:

* Query for SQL query text and input parameters (as shown here in <<database_operation_select>>).
* Streaming strategy settings (as shown here in <<database_streaming>>):
 ** None (Default)
 ** Non repeatable iterable ()
 ** Repeatable file store iterable (for  link://connectors/database-documentation#repeatable-file-store-iterable[maximum in-memory size and buffer unit settings])
 ** Repeatable in memory iterable (for link:/connectors/database-documentation#repeatable-in-memory-iterable[in-memory and buffer settings])
* Transactional action for the type of joining action that operations can take regarding transactions: ALWAYS_JOIN, JOIN_IF_POSSIBLE (Default), NON_SUPPORTED
* Query settings
* Target variable output settings
* Reconnection strategies
* Error mapping for errors, including DB:BAD_SQL_SYNTAX, DB:QUERY_EXECUTION
* Mule 4 input and output metadata for attributes, payload, and variables

[[database_operation_select]]
=== Select Operation

The Select (`<db:select />`) operation retrieves information from the RDBMS. It takes a SQL query and uses DataWeave to supply the parameters.

Notice that the Mule 3 example uses the parameterized SQL query within  `<db:parameterized-query />`.

.Mule 3 Example: SELECT
[source,xml]
----
<db:select config-ref="databaseConfig" doc:name="Database">
    <db:parameterized-query>
      <![CDATA[select first_name from employees where last_name = #[message.inboundProperties.'http.query.params'.lastname]]]>
    </db:parameterized-query>
</db:select>
----

Notice that the Mule 4 example uses `<database:input-parameters />` to set the value of the `last_name` input parameter that is used in the WHERE clause of the SQL query.

.Mule 4 Example: SELECT
[source,xml]
----
<database:select config-ref="databaseConfig">
  <database:sql>
    select * from employees where last_name = :last_name
  </database:sql>
  <database:input-parameters>
    <![CDATA#[{'last_name' : payload}]]]>
  </database:input-parameters>
</database:select>
----

Input parameters are supplied as key-value pairs, which you can create by embedding a DataWeave script. Those keys are used with the semicolon character (`:`) to reference a parameter value by name. This approach is recommended to avoid SQL injection attacks, and it allows the connector to perform optimizations that improve the overall performance of the Mule app.

[[database_dynamic_queries]]
== Dynamic Queries

Sometimes you not only need to parameterize the WHERE clause but also to parameterize parts of the query itself. Use cases for this include queries that need to hit online or historic tables depending on a condition, or complex queries where the project columns need to vary.

In Mule 3, the concept of SELECT was split into parameterized and dynamic queries, and you could not use both at the same time. You had to choose between having a dynamic query or using parameters (for SQL Injection protection, PreparedStatement optimization, and so on). Furthermore, the syntax to do one or the other was different, so you had to learn two different ways of doing the same thing.

.Mule 3 Example: SELECT with Parameterized Query
[source,xml]
----
<db:select config-ref="databaseConfig" doc:name="Database">
  <db:parameterized-query/>
</db:update>
----

.Mule 3 Example: SELECT with Dynamic Query
[source,xml]
----
<db:select config-ref="databaseConfig" doc:name="Database" >
  <db:dynamic-query/>
</db:select>
----

The Database Connector for Mule 4 can use both methods at the same time through expressions in the query. In the Mule 4 example, the expression produces the query by building a string in which the table depends on a variable. Notice that although the query text is dynamic, it still uses input parameters.

.Mule 4 Example
[source,xml]
----
<set-variable value="PLANET" doc:name="Set Variable"
 doc:id="9712c6fb-b9c2-4663-b3c7-d756c81f5444" variableName="table"/>
<db:select doc:name="Select"
 doc:id="9ea907ea-fd37-47b9-ad07-70c0521bac8d" config-ref="databaseConfig">
  <db:sql >SELECT * FROM $(vars.table) WHERE name = :name</db:sql>
  <db:input-parameters >
   #[{'name' : payload}]
  </db:input-parameters>
</db:select>
----

It is important to note that Input Parameters can only be applied to parameters in a WHERE clause.

////
Got a CDATA in 7.1 actually. Not sure if that's correct:
<![CDATA[{'name' : payload}]]>
Mariano's example here seems a bit out of date:
// TODO: IS THIS OUT OF DATE?
<set-variable variableName="table" value="PLANET"/>
<database:select config-ref="databaseConfig">
 <database:sql>#["SELECT * FROM $(vars.table) WHERE name = :name"]</database:sql>
 <database:input-parameters>
   #[{'name' : payload}]
 </database:input-parameters>
</database:select>
////
// TODO: SHOULD WE DISCUSS THE DW INTERPOLATION OPERATOR?

<<database_streaming>>
== Streaming Large Results

Database tables tend to be big. A single query might return tens of thousands of records, especially for integration use cases. Streaming is a great solution for this. What does streaming mean? Suppose you have a query which returns 10K rows. Attempting to fetch all those rows at once will result in the following:

* Performance degradation, since that’s a big pull from the network.
* A risk of running out of memory, since all that information needs to be loaded into RAM.

Streaming means that the connector will not fetch the 10K rows at once. Instead, it will fetch a smaller chunk, and once that chunk has been consumed it will fetch the rest. That way, you can reduce pressure over the network and memory.

In Mule 3.x this was something you had to specifically enable because it was disabled by default. In Mule 4, this is transparent and always enabled, you don’t have to worry about it anymore. You can simply trust that the feature is there.

.Mule 3 Example: Enabling Streaming
[source,xml]
----
TODO: show streaming enabled
----

.Mule 4 Example: Streaming Automatically Enabled
[source,xml]
----
TODO: show example of same process without setting for enabling streaming
----

// NOTE: WHAT'S BELOW IS NEW AND DOES NOT HAVE A MIGRATION IMPACT, SO PROB NOT NEEDED
Another improvement from Mule 3 is that you can now use the new repeatable streams mechanism from Mule 4. That means that streams are now repeatable, and you can make DataWeave and other components process the same stream many times, even in parallel.

[[database_insert_update_delete]]
== Insert, Update, and Delete Operations

The Insert, Update, and Delete operations also support the use of DataWeave parameters to get results from dynamic queries.

.Mule 4 Example: Insert with
[source,xml]
----
<db:insert config-ref="databaseConfig">
  <db:sql>
    INSERT INTO PLANET(POSITION, NAME, DESCRIPTION) VALUES (777, 'Pluto', :description)
  </db:sql>
  <db:input-parameters>
    #[
    {'description' : payload}
    ]
  </db:input-parameters>
</db:insert>
----

.Mule 4 Example: Update
[source,xml]
----
<db:update config-ref="databaseConfig">
  <db:sql>
    UPDATE PLANET SET DESCRIPTION = :description where POSITION = :position
  </db:sql>
  <db:input-parameters>
  #[
    {'description' : payload,
    'position' : 7,
    }
  ]
  </db:input-parameters>
</db:update>
----

.Mule 4 Example
[source,xml]
----
<db:delete config-ref="databaseConfig">
  <db:sql>
    DELETE FROM PLANET where POSITION = :position
  </db:sql>
  <db:input-parameters>
  #[
    {'position' : 7}
  ]
  </db:input-parameters>
</db:delete>
----

[[database_operation_bulk]]
== Bulk Operations

The Insert, Update, and Delete operations above are fine for the cases in which each input parameter can take only one value.

For example, when deleting, many rows might match the criteria and get deleted, but only one criterion (`POSITION = X`) is provided. The same concept applies for Update. That is, if you run `UPDATE PRODUCTS set PRICE = PRICE * 0.9 where PRICE > :price`, you might be applying a 10% discount on many products, but the `price` input parameter will only take one value. To apply _different_ discount rates on products that have different prices, you can either execute many operations, or can use the Bulk operation.

For example, assume you have a payload that is a list of objects of the following structure: `{ price : number, discountRate: number}`. You can execute many operations like this:

.Mule 4 Example: Executing Many Operations to Get Different Values
[source,xml]
----
<foreach>
  <db:update config-ref="databaseConfig">
    <db:sql>
      UPDATE PRODUCTS set PRICE = PRICE * :discountRate where PRICE > :price
    </db:sql>
    <db:input-parameters>
     #[
      {
        'discountRate' : payload.discountRate,
        'price' : payload.price,
      }
    ]
    </db:input-parameters>
  </db:update>
</foreach>
----

Though the approach above works, it is inefficient because the query needs to be executed for each element in the list. For each element, you have to do this:

* Parse the query.
* Resolve parameters.
* Get a connection to the database (either by getting one for the pool or establishing a new one).
* Pay all the network overhead.
* The RBMS has to process the query and apply changes.
* Release the connection.

You can avoid that inefficiency with a Bulk operation. In the example above, the UPDATE statement is constant, not dynamic. The only thing that changes is that each iteration supplies a different set of parameters.

Bulk operations allow you to run a single query using a set of parameters values. Make no mistake though, this is not just a shortcut for the same `<foreach>` above. This uses features on the JdatabaseC API so that:

* The query is parsed only once.
* Only one database connection is required since a single statement is executed.
* Network overhead is minimized.
* RBDMS can execute the bulk operation atomically.

For these use cases, the connector offers three operations, `<bulk-insert>`, `<bulk-update>`, and `<bulk-delete>`.

These are similar to their single counterparts, except that instead of receiving input parameters as key-value pairs, they expect them as a list of key-value pairs.

.Mule 4 Example: Using the Bulk Operation to Get Different Values
[source,xml]
----
<db:bulk-insert config-ref="databaseConfig" >
  <db:sql>
    insert into customers (id, name, lastName) values (:id, :name, :lastName)
  </db:sql>
  <db:bulk-input-parameters>
    #[[{'id': 2, 'name': 'George', 'lastName': 'Costanza'}, {'id': 3, 'name': 'Cosmo', 'lastName': 'Kramer'}]]
  </db:bulk-input-parameters>
</db:bulk-insert>
----

////
== TODO/NOTE: Other Topics Discussed in the Spec

QUESTION: SHOULD WE cover any of these?

spec here: https://docs.google.com/document/d/1zQLrSomGj8C5S7N5FDIVk1ThPiXTOWO9LVbxfSxjFAo/edit#heading=h.z8xftz3l7kjd

* Pooling Profile?
* Connections
  - Generic JdatabaseC connection
  - Global DataSource reference connection
  - Connection Types: MySQL, Derby, Oracle
  - Common Connection Parameters?
* Parameter Types
* Stored Procedure
////

////

[[database_connection_pooling]]
== Connection Pooling

Pooling configuration for JDBC Data Sources is capable of pooling connections. Note that this profile is targeted at data sources and is not the standard pooling profile used by other connectors.

.Mule 3 Example
[source,xml]
----
TODO
----

.Mule 4 Example
[source,xml]
----
TODO
----
////


== See Also

link:/connectors/database-documentation[Database Connector Documentation Reference]

link:migration-examples[Migration Examples]

link:migration-patterns[Migration Patterns]

link:migration-components[Migrating Components]

= Introduction to Mule 4: the Mule Message

Mule 4 includes a simplified Mule message model in which each Mule event has a message and variables associated with it. A Mule message is composed of a payload and its attributes (metadata, such as files size). Variables hold arbitrary information such as messages, payload data, or attributes. This simplified message model makes it easier to work with data in a consistent way across connectors without overwriting information.

== Inbound Properties Are Now Attributes

In Mule 3, inbound properties were used to store additional information about a payload obtained through a Message Source, such as the query parameters coming through an HTTP listener. Attributes are the successor to these, and have these advantages: 

* They are strongly typed, so you can easily see what data is available and 
* They can easily be stored in a variables for access throughout your flow. Here's an example of a typical Mule Message in Mule 4, which is from an HTTP Listener:

image:mule-message.png[Mule Message structure in Mule 4]

Attributes can be easily accessed through expressions, just as inbound properties were in Mule 3, for example:
[source,linenums]
----
attributes.requestPath
attributes.queryParams.searchCriteria
----

== Outbound Properties

In Mule 3, connectors and transports which need to send additional data such as headers, need to explicitly specify Outbound properties. For example, with the HTTP listener, you may want to specify the outgoing status code response or headers. In Mule 4, you can set each of those concept separately using individual DataWeave expression for each one of them, without introducing any side effects in the main flow:

[source,xml,linenums]
----
<http:request path="issues" config-ref="http" method="GET">
    <http:headers>#[{'path':'input/issues-list.json'}]</http:headers>
    <http:query-params>#[{'provider':'memory-provider'}]</http:query-params>
</http:request>
----

In the example above, we see how to do an HTTP request in which we uso individual DataWeave scripts to generate headers and query parameters, without the need to set message properties nor generating any side effects on the message.

The same concept can be applied for message sources which emits responses, such an HTTP listener:

[source,xml,linenums]
----
<http:listener config-ref="api-httpListenerConfig" path="/api/*" doc:name="Listener">
    <http:response statusCode="#[vars.httpStatus default 200]">
        <http:headers>#[vars.outboundHeaders default {}]</http:headers>
    </http:response>
    <http:error-response statusCode="#[vars.httpStatus default 500]">
        <http:body>#[payload]</http:body>
        <http:headers>#[vars.outboundHeaders default {}]</http:headers>
    </http:error-response>
</http:listener>
----

== Session Properties
Because transport barriers don't exist anymore, Session properties are no longer needed and have been removed in Mule 4. You should store data in variables

== Message Collections
One of the benefits of the new Mule Message structure is when dealing with collections. In Mule 3, components
that returned multiple payloads, used a special structure called the `MuleMessageCollection`. In Mule 4, any component
that needs to deal with multiple messages can simple set the payload of the message to a List of Mule Messages. You can
then iterate over these messages using DataWeave, For Each, or other components.

For example, when using the `<file:list>` operation, it retrieves a list of Messages. Each Message has Attributes for
each file, making it easy to make decisions based on file size, whether it's a directory, etc.

////
TODO: COMMENTED OUT TO AVOID DELETING SOMETHING IMPT WHEN FIXING MERGE CONFLICTS
This enables you to set those variables elsewhere in your flow, without having to worry about another connector overwriting them, as you did in Mule 3. For example:
[source,xml,linenums]
----
<set-variable variableName="httpStatus" value="#[200]"/>
----

== Session Properties
Session properties have been removed in Mule 4. Instead, you should store data in variables and explicitly
map the data you want to send through session boundaries. This practice provides a more secure out-of-the-box experience and
less unexpected behavior.

== Enrich from Anywhere
For any given module operation, it is now possible to define a target (or target variable), which saves the result in a variable:

[source,XML,linenums]
----
<http:request target="myVar" config-ref="requestConfig" method="GET" url="http://mulesoft.com"/>
----

This saves the Mule message in the `myVar` variable to be accessed later. This reduces flow complexity by removing the need for an Enricher component.

You can also control what is stored in the variable using the `targetValue` attribute. For example, if you just want to store the response code from an HTTP request, you can do the following:

[source,XML,linenums]
----
<http:request target="myVar" targetValue="#[attributes.statusCode]" .../>
----

== Message Collections
One of the benefits of the new Mule message structure is apparent when dealing with collections. In Mule 3, components
that returned multiple payloads used a special structure called the `MuleMessageCollection`. In Mule 4, any component
that needs to deal with multiple messages can simple set the payload of the message to a List of Mule Messages. You can
then iterate over these messages using DataWeave, For Each, or other components.

For example, the File List operation retrieves a list of Mule messages. Each message has attributes for
each file, making it easy to make decisions based on file size, whether it's a directory, and so on.
////

== See Also

link:migration-core-enricher[Migrating the Enricher to a Target Variable]

// sme: Ana, author: sduke?
= Introduction to Mule 4: Error Handlers

In Mule 4, error handling is no longer limited to a Java exception handling process that required you to check the source code or force the error to understand what happened. Though Java `Throwable` errors and exceptions are still available, Mule 4 introduces a formal Error concept that's easier to use. Now, each component declares the type of errors it may throw, so you can identify potential errors at design time.

== Mule Errors
Execution failures are represented with Mule errors that have the following components:

* A description regarding the problem
* A type, used to characterize the problem
* A cause, the underlying Java Throwable that resulted in the failure
* An optional error message, which is used to include a proper Mule Message regarding the problem

For example, when an HTTP request fails with a 401 status code, a Mule Error provides the following information:

-----
Description: HTTP GET on resource ‘http://localhost:36682/testPath’ failed: unauthorized (401)
Type: HTTP:UNAUTHORIZED
Cause: a ResponseValidatorTypedException instance
Error Message:  { "message" : "Could not authorize the user." }
-----

== Error Types
In the example above, the error type is HTTP:UNAUTHORIZED, not simply UNAUTHORIZED. Error types consist of both namespace and an identifier, allowing you to distinguish the types according to their domain: we have HTTP:NOT_FOUND and FILE:NOT_FOUND, for example. While connectors define their own namespace, core runtime errors have an implicit one: MULE:EXPRESSION and EXPRESSION are interpreted as one.

Another important characteristic of error types is that they may have a parent type. For example, HTTP:UNAUTHORIZED has MULE:CLIENT_SECURITY as the parent, which, in turn, has MULE:SECURITY as the parent. This establishes error types as specifications of more global ones: an HTTP unauthorized error is a kind of client security error, which is a type of a more broad security issue.

These hierarchies mean routing can be more general, since, for example, a handler for MULE:SECURITY will catch HTTP unauthorized errors as well as OAuth errors. Below you can see what the core runtime’s hierarchy looks like:

image::error-hierarchy.png[Error Hierarchy]

All errors are either general or CRITICAL, the latter being so severe that they cannot be handled. At the top of the general hierarchy is ANY, which allows matching all types under it. It’s important to note the UNKNOWN type, which is used when no clear reason for the failure is found.

This error can only be handled through the ANY type to allow specifying the unclear errors in the future, without changing existing apps behavior. When it comes to connectors, each connector defines its error type hierarchy considering the core runtime one, though CONNECTIVITY and RETRY_EXHAUSTED types are always present––since they are common to all connectors.

== Error Handlers

Mule 4 has redesigned handling errors, by introducing the error-handler component, which can contain any number of internal handlers and can route an error to the first one matching it. Such handlers are on-error-continue and on-error-propagate, which both allow conducting matching through an error type (or group of) or through an expression (for advanced use cases). These are quite similar to the choice, catch, and rollback exceptions strategies of Mule 3; however, they are much simpler and more consistent.

If an error is raised within a flow, its error handler will be executed and the error will be routed to the first matching handler. At this point, the error is available for inspection, so the handlers could execute and act accordingly:

* An on-error-continue will execute and use the result of the execution, as the result of its owner––as if the owner had actually completed the execution successfully. Any transactions at this point would be committed as well.
* An on-error-propagate will rollback any transactions, execute, and use that result to rethrow the existing error––meaning its owner will be considered as “failing.”

Consider the following application where an HTTP listener triggers a flow reference to another flow that performs an HTTP request. If everything goes right when a message is received (1) the reference is triggered (2) and the request performed (3), resulting in a successful response (4).

image::error-handling-example-1.png[Error Handling Example 1]

If the HTTP request fails with a not found error (3), because of the error handler setup of inner-flow, then the error will be propagated (4), and the flow reference will fail as well (2). However, since primary-flow is handling that with an on-error-continue, this will execute (5) and a successful response will be returned (6).

image::error-handling-example-2.png[Error Handling Example 1]

Should the request fail with an unauthorized error instead (3), then the inner-flow will handle it with an on-error-continue by retrieving static content from a file (4). Then, the flow reference will be successful as well (2) and a successful response will be returned (5).

image::error-handling-example-3.png[Error Handling Example 3]

But what if another error occurred in the HTTP request? Although there are only handlers for “not found” and “unauthorized” errors in the flow, errors are still propagated by default. This means that if no handler matches the error that is raised, then it will be rethrown. For example, if the request fails with a method not allowed error (3), then it will be propagated causing the flow reference to fail (2), and that propagation will result in a failure response (4).

image::error-handling-example-4.png[Error Handling Example 4]

The scenario above could be avoided by making the last handler match ANY, instead of just HTTP:UNAUTHORIZED. Notice how, below, all the possible errors of an HTTP request are suggested:

image::error-handling-any.png[Error Handling Any]

You can also match errors using an expression. For example, since the Mule Error is available during error handling, we can use it to match all errors whose namespace is HTTP:

image::error-handling-expression.png[Error Handling Expression]

== Try Scope
For the most part, Mule 3 only allows handling errors at the flow level, forcing you to extract logic to a flow in order to address errors. In Mule 4, we’ve introduced a try scope that you can use within a flow to do error handling of just inner components. The scope also supports transactions––replacing the old transactional scope.

image::error-handling-try.png[Try Scope]

The error handler behaves as we have explained earlier. In the example above, any database connection errors will be propagated, causing the try to fail and the flow’s error handler to execute. In this case, any other errors will be handled and the try scope will be considered successful which, in turn, means that the following processor, an HTTP request, will continue executing.

== Error Mappings
Mule 4 now also allows mapping errors to custom ones. The try scope is very useful, but if you have several equal components and wish to distinguish the errors of each one, using a try on them can clutter your app. Instead, you can add error mappings to each component, meaning all or certain kind of errors steaming from the component will be mapped to another error of your choosing. If, for example, you are aggregating results from 2 APIs using an HTTP request component for each, you may want to distinguish between the errors of API 1 and API 2, since by default their errors will be the same.

By mapping errors from the first request to a custom API_1  error and errors in the second request to API_2 you can route those errors to different handlers. In the example below, we are mapping HTTP:INTERNAL_SERVER_ERROR, so different handling policies can be applied in case the APIs go down (propagating the error in the first API and handling it in the second API).

image::error-handling-mappings.png[Error Handling Mappings]

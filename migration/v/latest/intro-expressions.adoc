= Mule 4 for Mule 3 Users: DataWeave Expression Language
In Mule 3, users had to contend with learning both the Mule Expression Language (MEL) and DataWeave. MEL forced users to convert their payloads from binary data, such as XML or JSON documents, into Java objects, so they could write expressions which access that data, for example when routing to a specific location.

In Mule 4, DataWeave is now the default expression language. Combined with the built-in streaming capabilities, this simplifies many common tasks:
* Events can be routed based on payload data, without first needing to convert to Java objects.
* Binary data can easily be queried from an expression anywhere in your flow, for example, when logging.
* Larger than memory access to data happens transparently.

DataWeave 2.0 also features many improvements, which are covered in the link:intro-dataweave[DataWeave 2.0] section.

At the core, expressions continue to work like before. You can use them to extract data, log data, or make decisions on where to route data.
And like MEL, the syntax to access properties in your data, is very simple.

[source,xml,linenums]
----
<logger message="#[payload]"/>
<set-variable variableName="httpStatus" ="#[attributes.http]"/>
----

Unlike MEL, you can use DataWave to easily access data anywhere in your flow - without having to worry about transforming it into intermediate objects. Take this example in Mule 3:
[source,xml,linenums]
----
<http:listener path="/hello"/> <!-- receives a JSON HTTP Body -->
<json:json-to-object/> <!-- convert to Java objects -->
<choice> <!-- route data based on the data -->
  <when expression="#[payload.customer == 'Acme, Inc']">
    <!-- do some logic -->
  </when>
</choice>
----
In Mule 4, you no longer need to convert JSON to an intermediate format. You can simply access the data directly via expressions, without losing the original underlying data. And, as we'll discuss in the following sections, Mule 4handles all data streaming and random access transparently for you.
[source,xml,linenums]
----
<http:listener path="/hello"/> <!-- receives a JSON HTTP Body -->
<choice> <!-- route data based on the data -->
  <when expression="#[payload.customer == 'Acme, Inc']">
    <!-- do some logic -->
  </when>
</choice>
----

== Expressions vs. Code
Experienced Mule users will notice that DataWeave takes a more opinionated approach to what users can can do with the expression language.
The intention here is to provide clearly separation between business logic that should be extracted via code, and the flow logic.

If you wish to extract, query, transform or otherwise work with data in your flows, DataWeave expressions and
transforms are the recommended tool. If you wish to write complex logic, instantiate Java objects, call arbitrary methods
we recommend that you encapsulate this code into scripts or classes, which can be easily injected and tested.

For the times where you want to call out to Java logic to aide in formatting or parsing of data, DataWeave now allows you to call out to static functions. Take this Java function:
[source,DataWeave,linenums]
----
package org.acme;
public class MyCompanyUtils {  
  public static String reformat(String input) {    
    return â€¦;  
  }
}
----
You can call it via the following DataWeave code:
[source,DataWeave,linenums]
----
import java!org::acme::MyCompanyUtils
---
{
  date: MyCompanyUtils::reformat(payload.input)
}
----

== See Also
 * link:migration-dataweave[DataWeave Migration Reference]
 * link:/mule-user-guide/4.0/dateweave[DataWeave 2 Reference]
 * TODO - scripting module

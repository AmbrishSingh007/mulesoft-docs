= Introduction to Mule 4: Java Integration

== Expressions vs. Code
Experienced Mule users will notice that Mule 4 takes a more opinionated approach to how applications should be structured,
limiting what can be done in the expression language.
The intention here is to provide a clear separation between business logic that should be extracted via code, and the flow logic. 

If you wish to extract, query, transform or otherwise work with data in your flows, DataWeave expressions and
transforms are the recommended tool. If you wish to write complex logic, instantiate Java objects, call arbitrary methods
we recommend that you encapsulate this code into scripts or classes, which can be easily injected and tested. 
This means that we've removed the Expression Component and Expression Transformer in favor of encouraging users to cleanly separate 
their logic into scripts or Java classes instead.

== Calling Java Functions from DataWeave

For the times where you want to call out to Java logic to aide in formatting or parsing of data, DataWeave now allows you to call out to static functions. Take this Java function:
[source,Java,linenums]
----
package org.acme;
public class MyCompanyUtils {
  public static String reformat(String input) {
    return â€¦;
  }
}
----
You can call it via the following DataWeave code:
[source,DataWeave,linenums]
----
import java!org::acme::MyCompanyUtils
---
{
  date: MyCompanyUtils::reformat(payload.input)
}
----

== Calling Java Components From Flows
// TODO

=== Scripting Module
The scripting module is now updated for Mule 4, enabling you to now embed your Groovy, Ruby, Python, or JavaScript scripts inside Mule flows. You can inject data from the Mule message into your code using the new parameters configuration attribute.

[source,XML,linenums]
----
<script:execute engine="groovy">
    <script:code>
         return "$payload $prop1 $prop2"
    </script:code>
    <script:parameters>
         #[{prop1: "Received", prop2: "A-OK"}]
    </script:parameters>
</script:execute>
----

// sme: MG, author: sduke?
= Migrating the File Connector

// Explain generally how and why things changed between Mule 3 and Mule 4.
In Mule 3, you can place a File connector at the beginning of the flow to make it act as an inbound endpoint that triggers the flow at a given polling interval. As an inbound endpoint, the connector reads the file, then dispatches the results to the next processor in the flow. It can also move a copy of the file to a new directory on the file system.

Further, in Mule 3, `<file:inbound-endpoint />` is asynchronous by default and only operates synchronously when using the `synchronous` processing strategy. This can pose issues in cases where you need confirmation that the file could be written or when using it in batch.

In Mule 4, the File connector is completely new. Here are the main changes:

* The File connector no longer serves as a trigger (message source) for inbound processes, nor does it contain a built-in poller. Instead, you use a separate component, such as a Scheduler or HTTP listener, to trigger any File connector processes in a flow. This separation means that you can copy, list, and move files at any point in the flow, rather than at a polling interval.
* The connector configuration is much simpler in Mule 4 than Mule 3. There are far fewer settings, and operation-related settings, such as `writeToDirectory` and `moveToDirectory`, are no longer part of the configuration.
* All File connector processes (such as Read, Write, Move and so on) have been refactored into separate operations. Unlike in Mule 3, the Mule 4 operations provide settings operation-specific configurations, such as the directory from which to read, write, move, or copy files.
* You use DataWeave version 2 expressions and scripts instead of the Mule Expression Language (MEL) or DataWeave version 1 within File connector and configuration fields.
* Changes to the Mule message and event in Mule 4 affect accessors to use for file attributes and properties. In particular, file metadata is stored as attributes in the Mule message, and you access them, for example, with `#[attributes.lastModifiedTime]`.
* Provides mappings to error types that are specific to the File connector, such as FILE:CONNECTIVITY.
* Processes are synchronous in Mule 4 unless you put them in an Async scope.
//* The connector always returns an `InputStream`. List operation returns a `TreeNode`.

//* The Mule streaming framework is automatically configured for your operations. You can execute a select statement and process the results asynchronously without worrying about leaking connections.

[[whats_covered_here]]
== What's Covered Here?

* <<file_configs>>
* <<file_config_refs>>
* <<file_operations>>
 ** <<operation_read>>
 ** <<file_copy>>
 ** <<file_move_rename>>
* <<migrate_reconnection>>

[[file_configs]]
== Migrating File Connector Configurations

In Mule 3, all connector configurations are set under a top-level element called `<file:connector />`, and by default, the File connector sets auto-deletion, streaming, and validation of the connections to `true`.

.Mule 3 Example: Default File Configuration
[source,xml, linenums]
----
<file:connector name="file_config_default"
 autoDelete="true"
 streaming="true"
 validateConnections="true"
 doc:name="File"/>
----

The connector configuration also provides settings for reading, writing, and moving files, among many others. The next example shows most of the Mule 3 setting available to the File connector.

.Mule 3 Example: Available File Connection Settings
[source,xml, linenums]
----
<spring:beans>
    <spring:bean id="MyBean" name="MyBean"/>
</spring:beans>

<file:connector name="file_config_most_settings"
 outputPattern="FileNamePattern"
 writeToDirectory="WriteToDirectory"
 readFromDirectory="ReadFromDirectory"
 workDirectory="WorkDirectory"
 workFileNamePattern="WorkFileNamePattern"
 autoDelete="true"
 outputAppend="true"
 streaming="true"
 dispatcherPoolFactory-ref="MyBean"
 recursive="true"
 dynamicNotification="true"
 validateConnections="true"
 serialiseObjects="true"
 pollingFrequency="4000" fileAge="800"
 moveToPattern="MoveToPattern"
 moveToDirectory="MoveToDirectory"
 doc:name="File" doc:description="Notes">
  <file:expression-filename-parser/>
  <spring:property name="Name" value="Value"/>
</file:connector>
----

In Mule 4, `<file:config />` is the the top-level element for the file connection configuration, and `<file:connection />` is a child element for connection-related settings.

.Mule 4 Examples
[source,xml, linenums]
----
<file:config name="file_config"
 doc:name="file_config"
 doc:id="5ff39ab7-0c61-474b-9814-290a69cbca52"
 defaultWriteEncoding="UTF-8">
  <file:connection workingDir="/Users/me/path/to/files" >
      <reconnection failsDeployment="true" >
        <reconnect-forever />
      </reconnection>
  </file:connection>
  <expiration-policy maxIdleTime="12" timeUnit="MILLISECONDS" />
</file:config>
----

* `workingDir` identifies the location of your files. `workingDir` is the only required setting. (Note that in Mule 3, `workDirectory` is a similarly named attribute, but `workDirectory` is used when moving input files before processing them.)
* `defaultWriteEncoding` identifies the character encoding to use for writing. You can overwrite this global configuration with a File operation, such as Write.
+
// TODO: NEED DESCRIPTION, I BELIEVE IT DEFAULTS TO THE MULE RUNTIME ENCODING.
+
* `reconnection` is for reconnection strategies for cases where the initial attempt to connect fails (see link:migration-patterns-reconnection-strategies[Migrating Reconnection Strategies]).
* `expiration-policy` is for idle configuration instances (see link:migration-patterns-expiration-policies[Expiration Policies]).

[[file_config_refs]]
== Referencing File Connection Configurations

In Mule 3, all operations are set as inbound or outbound endpoints that use `connector-ref` to point to a name File connector configuration.

.Mule 3 Example: File Connection as Inbound Endpoint
[source,xml, linenums]
----
<file:inbound-endpoint path="/tmp/input"
  connector-ref="file_config"
  responseTimeout="10000"
  doc:name="File"
  ... />
----

.Mule 3 Example: File Connection as Outbound Endpoint
[source,xml, linenums]
----
<file:outbound-endpoint path="/tmp/output"
 connector-ref="file_config"
 responseTimeout="10000"
 doc:name="File"
 ... />
----

[[file_operations]]
== Migrating File Operations

In Mule 4, all operations are specified within separate, top-level elements that use `config-ref` to point to a named File connector configuration.

Note that the File connector has the same set of operations as the FTP and SFTP connectors. Each operation behaves almost identically for the connectors.

.Mule 4 Examples: Operations
[source,xml, linenums]
----
<file:copy doc:name="Copy"
 doc:id="0e10e616-1577-445b-b903-755366798e50"
 config-ref="file_config"
 ... />
<file:create-directory doc:name="Create directory"
 doc:id="3f93fb6d-af6b-430e-bf7c-5d8471cfc340"
 config-ref="file_config"
 ... />
<file:delete doc:name="Delete"
  doc:id="954301f2-393d-4d83-beed-fe5a87da9aca"
  config-ref="file_config"
  ... />
<file:list doc:name="List"
 doc:id="db1f62b9-b6fd-448b-836b-e0ae36f516b6"
 ... />
<file:move doc:name="Move"
 doc:id="77382c43-de2d-44c5-b97c-cb8c4493bc1a"
 ... />
<file:read doc:name="Read"
 doc:id="4a5e4652-7840-4e30-bbeb-b94430cc037e"
 ... />
<file:rename doc:name="Rename"
 doc:id="f6436a0d-08b9-42ab-acea-8a5c3d8ba450"
 ... />
<file:write doc:name="Write"
 doc:id="aeb168f2-d240-41a3-8f45-80cdbca9c1a1"
 ... />
----

[[operation_read]]
=== Migrating Read Operations

In Mule 4, the File connector can use the Read operation (`<file:read />`) to read a file at any point in the flow, unlike the Mule 3 transport, which can only read files as a result of polling (for example, `pollingFrequency="1000"`) by the inbound endpoint (`<file:inbound-endpoint />`.

Note that the inbound endpoint in Mule 3 triggers one message per file, which makes it difficult to use with the Batch module because you cannot have a job in which each file is a record. It also makes it difficult to perform watermarking, so some use file filters to produce the effect of Mule watermarking. In addition, use of use cases in which all obtained files need to be processed together required the use of an aggregator in Mule 3.

.Mule 3 Example: Reading a File
[source,xml, linenums]
----
<file:connector name="input"
 autoDelete="false"
 pollingFrequency="1000" />

<flow name="copyFile">
  <file:inbound-endpoint
   connector-ref="input" path="/tmp/input"/>
</flow>
----

In Mule 4, you can use components message sources such as the HTTP Listener or Scheduler to trigger a Read operation. The example here uses a Scheduler component (`<scheduler />`) to trigger the Read operation:

.Mule 4 Example: Read Operation
[source,xml, linenums]
----
<scheduler doc:name="Scheduler"
 doc:id="63e8cf24-6b5d-4872-bc79-eff52c8e75fb" >
  <scheduling-strategy >
    <fixed-frequency frequency="5000"/>
  </scheduling-strategy>
</scheduler>

<file:read doc:name="Read"
 doc:id="ad21fcc1-f4cf-4f44-97d0-4029bb8cf6fb"
 config-ref="File_Config"
 path="/Users/me/in/sample_json.json">
</file:read>
----

// TODO: HOW DO YOU READ EVERYTHING IN A DIR INSTEAD USING A STATIC FILENAME? DO YOU NEED TO USE A FOR EACH OR SOMETHING? CAN YOU USE DW IN THE PATH FIELD? OR REGEX?  OR WILDCARD OR SOMETHING LIKE THAT?

////
<file:read doc:name="Read"
 doc:id="ad21fcc1-f4cf-4f44-97d0-4029bb8cf6fb"
 config-ref="File_Config"
 path="/Users/me/in/sample_json.json"
 outputMimeType="application/json"
 lock="true" target="myVar">
  <ee:repeatable-file-store-stream />
  <reconnect />
</file:read>
////

[[file_copy]]
=== Migrating a Copy Process

This Mule 3 example uses two separate File connector components, the first to read a file through the `inbound-endpoint`, the second to write a copy of it to output directory using an `outbound-endpoint`.

.Mule 3 Example: Copy File
[source,xml, linenums]
----
<file:connector name="input"
 autoDelete="false"
 pollingFrequency="1000" />

<file:connector name="output"
 outputAppend="false"/>

<flow name="copyFile">
  <file:inbound-endpoint
   connector-ref="input" path="/tmp/input"/>
  <file:outbound-endpoint
   connector-ref="output" path="/tmp/output"/>
</flow>
----

In Mule 4, you can use a single Copy operation from the File connector to read and then write a copy to a new directory. You can also rename it and perform other processes often needed when copying a file.

.Mule 4 Example: Copy File
[source,xml, linenums]
----
<file:copy doc:name="Copy"
 doc:id="86e645b4-1844-48d5-b64b-fc0f55ae23c2"
 config-ref="File_Config"
 sourcePath="/Users/me/source/myfile.json"
 targetPath="/Users/me/output"
 createParentDirectories="true|false"
 overwrite="true|false"
 renameTo="renamed.json">
  <reconnect />
  <error-mapping
   sourceType="FILE:CONNECTIVITY"
   targetType="APP:FILE:CONNECTIVITY" />
</file:copy>
----

* `targetPath` is the path to the directory in which to copy (or move) a file. It must point to a directory.
* `renameTo` provides a new name for the copied file.
* `overwrite`, if set to `true` or `expression`, allows you to overwrite the file in the target path.
//TODO: YOU ALSO also provide a DataWeave expression instead of a Boolean.

Note that connector also provides error mapping source types for all operations:
* FILE:ILLEGAL_PATH
* FILE:FILE_ALREADY_EXISTS
* FILE:CONNECTIVITY
* FILE:RETRY_EXHAUSTED

[[file_move_rename]]
=== Migrating a Move Process

The Mule 3 example here uses the inbound endpoint (`<file:inbound-endpoint />`) to move files from `path="/tmp/input"` to `moveToDirectory="/tmp/backup"` every 5 seconds (`5000` ms). In Mule 4, you use a Move operation for this process.

Notice that the Mule 3 example also uses an `outputPattern` in the outbound endpoint (`<file:outbound-endpoint />`) to rename a copy of the input files from `path="/tmp/input"` and place them in `path="/tmp/output"`. In Mule 4, you use a Copy operation for this purpose (see <<file_copy>>).

.Mule 3 Example: Move File
[source,xml, linenums]
----
<file:connector name="input"
  autoDelete="true"
  fileAge="500"
  pollingFrequency="5000" />

<file:connector
  name="output"
  outputAppend="false"/>

<flow name="moveFile">
  <file:inbound-endpoint
   connector-ref="input"
   path="/tmp/input"
   moveToDirectory="/tmp/backup"
   moveToPattern="#[message.inboundProperties['originalFilename']].backup"/>

  <file:outbound-endpoint
   connector-ref="output"
   path="/tmp/output"
   outputPattern="#[function:datestamp]-#[message.inboundProperties['originalFilename']]"/>
</flow>
----

In Mule 4, the source and output paths for the file to move are set in a single Move operation. It uses `renameTo` to rename that file that it moves. You can also use create parent directories and reconnection strategies, as needed.

.Mule 4 Example: Move File
[source,xml, linenums]
----
<file:move doc:name="Move"
 doc:id="c74c444d-2683-450c-a2aa-10c9260d5b44"
 config-ref="File_Config"
 sourcePath="/Users/me/in/my_file.json"
 targetPath="/Users/me/out"
 createParentDirectories="false"
 overwrite="false"
 renameTo="#[now() ++ '_file.json']">
 <reconnect-forever frequency="3000" />
</file:move>
----

Note that the Write, Copy, and Move operations support the creation of parent directories if they do no exist already. All provide this setting: `createParentDirectories=true`

[[migrate_reconnection]]
== Migrating Reconnection Strategies

This topic is common to many connectors:

* link:migration-patterns-reconnection-strategies[Migrating Reconnection Strategies]

== See Also

link:https://docs.mulesoft.com/mule-user-guide/v/3.9/file-transport-reference[File Transport Reference] (Mule 3.9)

link:https://docs.mulesoft.com/mule-user-guide/v/3.9/file-connector[File Connector] (Mule 3.9)

link:/connectors/v/4.0/file-documentation[File Connector Documentation Reference] (Mule 4)

////
  TODO: NEED INFO ON HOW TO PICK UP A FILE BASED ON A FILE PATTERN WITH DW OR WHATEVER, INSTEAD OF A STATIC STRING.
[[file_list]]
=== Listing a File
  TODO: MULE 3 COUNTERPART?

    By default, this operation only lists the contents of the given directory, without going into any sub-folders at the root level of the Directory Path and without reading any file that is inside a subdirectory. To enable recursive listing, the Recursive parameter should be on True. If a sub-directory is found and recursive was set to True, then the files contained in that subdirectory will be listed immediately after the subdirectory.

    In combination with the file matcher, this capability makes it possible to use this connector in tandem with other Mule elements such as the <scheduler> to do “watermark-like” use cases.

    .Mule 3 Example
    [source,xml, linenums]
    ----
    TODO
    ----

    .Mule 4 Example
    In this example, we will list the contents of a folder and handle regular files and subdirectories differently. We do so by using the list operation, which lists all the files and folders in a given Directory Path. This path could be absolute or relative. If the path is relative, then it will be relative from the Config’s Working Directory. The list operation returns a List of messages, where each message represents an item in the directory.

    [source,xml, linenums]
    ----
    <flow name="list">
      <file:list directoryPath="~/dropFolder" />
      <foreach>
        <choice>
          <when expression="#[attributes.directory]">
            <flow-ref name="processDirectory" />
          </when>
          <otherwise>
            <logger message="Found file #[attributes.path] which content is #[payload]" />
          </otherwise>
        </choice>
      </foreach>
    </flow>
    ----

    [source,xml, linenums]
    ----
    <file:list doc:name="List"
     doc:id="50e485e3-d26d-46a4-90ad-c671a12ccaf8" config-ref="MyFileConfiguration"
     directoryPath="/directory/path"
     recursive="true">
      <file:matcher directories="EXCLUDE" symLinks="EXCLUDE" />
    </file:list>
    ----
=== Migrating Write
  TODO: HOW TO WRITE IN MULE 3
=== Migrating List
  TODO: HOW TO WRITE IN MULE 3
=== Migrating Rename?
  TODO: IS THERE A COUNTERPART IN MULE 3?
    In Mule 4, the Rename operation simply renames the file.

    .Mule 4 Examples: Rename File
    [source,xml, linenums]
    ----
    <file:rename doc:name="Rename"
     doc:id="91154749-24c2-4ba4-932e-b283b632be76"
     config-ref="File_Config"
     path="/Users/me/in/my_file.json"
     to="my_new_name.json"
     overwrite="true"/>

     <file:rename config-ref="file"
      path="#[path]"
      to="#[to]"
      overwrite="#[overwrite]"/>
    ----
=== Migrating Metadata
  TODO: THIS SHOULD BE COVERED AS A GENERAL TOPIC ELSEWHERE
=== Migrating Reconnection Strategies
  TODO: SEE Database migration guide. Probably move that to its own topic.
=== Migrating the Dispatched Pool Factory
  TODO? MIGRATE TO WHAT?
=== Migrating Spring Properties
  TODO? MIGRATE TO WHAT?
  // In Mule 3, FTP and SFTP connector configuration properties are the same as the File Connector.

  In Mule 3:

  * Name
  * Value
  * Reference

  * Subelements:
   ** Add Array
   ** Add Bean
   ** Add List
   ** Add Map
   ** Add Null
   ** Add Props
   ** Add Reference
   ** Add Set
   ** Add Value
   ** Add idef

   Mule 4:

   TODO: SEE IF POSSIBLE IN MULE. MIGRATE TO WHAT?
////

////
[[operation_on_new_file]]
=== On New File Operation

TODO: IS THIS WORKING? CANNOT MOVE FROM STUDIO 7 PALETTE TO FLOW.

.Mule 3 Example
[source,xml, linenums]
----
TODO?
----

.Mule 4 Example
[source,xml, linenums]
----
TODO?
----
////
////
The processor in the Mule 4 example reads the file in the given path. It returns a `MuleMessage` with the following attributes:

* An `InputStream` as payload
* A `FileAttributes` instance.

Attempts to read a directory or a file that does not exist result in an `FILE:ILLEGAL_PATH` error.

.Mule 4 Example: Mime Type, Encoding, Lock
[source,xml, linenums]
----
<file:read doc:name="Read" doc:id="ad21fcc1-f4cf-4f44-97d0-4029bb8cf6fb" config-ref="File_Config" path="/Users/staceyduke/Desktop/testing/sample_json.json" outputMimeType="application/json" lock="true" target="myVar">
  <ee:repeatable-file-store-stream inMemorySize="2" bufferUnit="MB"/>
  <reconnect frequency="3000" count="3"/>
</file:read>
----

The example above shows some important fields in the Read operation:

* `outputMimeType`: For setting a mime type of the file, such as `application/json`. By default, the connector attempts to determine the mime type of a file based on its extension.
+
DataWeave is the default expression language in Mule 4, and you can embed DataWeave expressions inside operations that generate payloads and other values. The mime type setting can help DataWeave assign types so that it generates the correct outputs.
+
* `outputEncoding`: For setting the file encoding. By default, the connector  uses the default Mule Runtime encoding, often UTF-8.
* `lock`: For applying a file system lock on the file while it is being read. Defaults to `false`. Setting it to `true` makes a request for the operating system to lock the file and thereby prevent any other process (or Mule flow) from accessing that file while the lock is held. The lock will be automatically released when one of the following things happen:
 ** The Mule flow, which locked the file, ends.
 ** The file content has been fully read.

Note that if the file is already locked, the connector will not be able to lock it, and you will get a `FILE:FILE_LOCK` error.
////

////
==== Streaming

TODO: SHOULD WE MENTION HERE? OR POINT ELSEWHERE?

The Write operation supports repeatable streams functionality. It returns a list of messages, each of which represents one of the files found. Each of those messages holds a stream to the found file, and that stream is repeatable by default.

Settings:

* None
* Non-repeatable stream
* Repeatable file store stream
* Repeatable in memory stream

.Mule 3 Example
[source,xml, linenums]
----
----

.Mule 4 Example
[source,xml, linenums]
----
----

==== TODO: Reconnection Strategies?

TODO: SHOULD WE MENTION HERE? OR POINT ELSEWHERE?

Settings:

* None
* Standard
* Forever

.Mule 3 Example
[source,xml, linenums]
----
----

.Mule 4 Example
[source,xml, linenums]
----
----


[[operation_write]]
=== Write Operation

This operation writes the content you provide to a path on demand. By default form, the connector will write whatever is in the message payload.

.Mule 3 Example
[source,xml, linenums]
----
TODO
----

.Mule 4 Example
[source,xml, linenums]
----
<file:write path="output.csv" />
----

If the payload is not in CSV format, and you need to make a transformation?

In Mule 3, it was necessary to perform a DataWeave transformation before the write operation, which caused the message payload to change and impacted the operation placed after the write operation.

.Mule 3 Example
[source,xml, linenums]
---
TODO: DW TRANSFORM BEFORE WRITE OPERATION
---

To avoid this undesired impact, you can now place the transformation inside the write operation:

.Mule 4 Example
[source,xml, linenums]
----
<file:write path="output.csv">
   <file:content>#[%dw 2.0

  output application/csv
  ---
  payload.customers.email
  ]
  </file:content>
</file:write>
----

Here, the transformation can generate the content that will be written without a side effect on the message in transit.

==== Writing into directories

Here, if directories `a`, `b`, or `c` do not exist, this operation fails by default:

.Mule .... TODO EXAMPLE
[source,xml, linenums]
----
<file:write path="a/b/c/myFile.txt" />
----

`createParentDirectories`: Set to `true` to automatically create any missing directories.

==== Writing to existing files

File write modes are important when you try to write to an existing file:

* OVERWRITE: If the file exists, then overwrite it completely.
* APPEND: If the file exists, then write at the end of it.
* CREATE_NEW: This means that the operation should result in a new being created. If the file is already there, then you will get an exception
This operation also supports locking, in a similar fashion to the read operation. The main difference is that the lock will be automatically released once the write operation finishes.

.Mule 3 Example
[source,xml, linenums]
----
----

.Mule 4 Example
[source,xml, linenums]
----
<file:write doc:name="Write"
 doc:id="cc35edda-9694-4bd1-a0ef-07f4196a074a"
 mode="CREATE_NEW"
 config-ref="MyFileConfiguration"
 path="/path/to/file"
 createParentDirectories="false"/>
----

[operation_list]]
=== List Operation

By default, this operation only lists the contents of the given directory, without going into any sub-folders at the root level of the Directory Path and without reading any file that is inside a subdirectory. To enable recursive listing, the Recursive parameter should be on True. If a sub-directory is found and recursive was set to True, then the files contained in that subdirectory will be listed immediately after the subdirectory.

In combination with the file matcher, this capability makes it possible to use this connector in tandem with other Mule elements such as the <scheduler> to do “watermark-like” use cases.

.Mule 3 Example
[source,xml, linenums]
----
TODO
----

.Mule 4 Example
In this example, we will list the contents of a folder and handle regular files and subdirectories differently. We do so by using the list operation, which lists all the files and folders in a given Directory Path. This path could be absolute or relative. If the path is relative, then it will be relative from the Config’s Working Directory. The list operation returns a List of messages, where each message represents an item in the directory.

[source,xml, linenums]
----
<flow name="list">
  <file:list directoryPath="~/dropFolder" />
  <foreach>
    <choice>
      <when expression="#[attributes.directory]">
        <flow-ref name="processDirectory" />
      </when>
      <otherwise>
        <logger message="Found file #[attributes.path] which content is #[payload]" />
      </otherwise>
    </choice>
  </foreach>
</flow>
----

[source,xml, linenums]
----
<file:list doc:name="List"
 doc:id="50e485e3-d26d-46a4-90ad-c671a12ccaf8" config-ref="MyFileConfiguration"
 directoryPath="/directory/path"
 recursive="true">
  <file:matcher directories="EXCLUDE" symLinks="EXCLUDE" />
</file:list>
----
////
////
====  Migrating a File Filter

In Mule 3, the File connector provides filtering elements, such as `<file:filename-wildcard-filter />` and

myCustomerFile(.*)

In Mule 4, the connector provides a file matcher for filtering files that match certain criteria. This element defines the possible criteria that can be used to either accept or reject a file. The `file:matcher` is a global component that you can use for file matching.

.Mule 3 Example: Filters
[source,txt, linenums]
----
<file:filename-wildcard-filter pattern=".txt,.xml"/>

<filename-regex-filter="myCustomerFile(.*)"
----

.Mule 4 Example
[source,xml, linenums]
----
<file:matcher
  filename-pattern="a?*.{htm,html,pdf}"
  path-pattern="a?*.{htm,html,pdf}"
  createdSince="2015-06-03T13:21:58+00:00"
  createdUntil="2015-07-03T13:21:58+00:00"
  updatedSince="2015-05-03T13:21:58+00:00"
  updatedUntil="2015-06-03T13:21:58+00:00"
  accessedSince="2015-06-03T13:21:58+00:00"
  accessedUntil="2015-06-03T13:21:58+00:00"
  directory="true|false"
  regularFile="true|false"
  symbolicLink="true|false"
  minSize="0"
  maxSize="1024" />
----

All of the attributes above are optional and are ignored if not provided. They are all related to each other under an `AND` operator.

The file matcher can be a reusable top-level element, or it can be used as an inner element proprietary to a particular component.


.Mule 4 Example: Top-Level, Reusable Matcher
[source,xml, linenums]
----
<file:matcher name="smallFileMatcher" maxSize="100" />

<flow name="smallFiles">
  <file:list path="~/smallfiles" matcher="smallFileMatcher" />
  ...
</flow>
----

.Mule 4 Example: Inner, Single Use, Matcher
[source,xml, linenums]
----
<flow name="smallFiles">
	<file:list path="~/smallfiles" matcher="smallFileMatcher">
    <file:matcher maxSize="100" />
	</file:list>
	...
</flow>
----

=== Migrating the Parser Settings

TODO: SEE IF THERE'S ANYTHING TO MIGRATE TO, WHAT IS THIS ANYWAY?

No child elements for `custom-filename-parser`.

Custom Filename Parser
* Attribute Name: class
* Type: string
* Required: yes
* Description: The implementation class name that implements org.mule.transport.file.FilenameParser.


== TO ORGANIZE OR REMOVE
// Describe what changed from 3.x to 4.x
The configuration elements, attributes, and XML structure have changed substantially in the File connector for Mule 4.

.Mule 3 Examples
[source,xml, linenums]
----
<file:connector
 name="MyFileConfiguration1"
 autoDelete="true"
 streaming="true"
 validateConnections="true"
 doc:name="File"/>

<file:connector name="MyFileConfiguration2"
 workDirectory="myDir"
 autoDelete="false"
 streaming="false"
 validateConnections="false"
 doc:name="File"
 doc:description="My note here."/>
----
== Migrating Filters to Watermarks

The inbound endpoint triggers one message per file, which made using the watermark difficult and required user to learn to use filters.

You can now use watermarks instead of filters for this purpose. For example, you might use a watermark with the List operation in Mule 4.

For details:

* link:migration-patterns-watermark[Migrating Watermarks].

For background information:

* link:/connectors/object-store-to-watermark[Example: To do Watermarks with ObjectStore] (Mule 4 documentation)

* https://docs.mulesoft.com/mule-user-guide/v/3.9/filters[Filters] (Mule 3.9 documentation)

[[file_advanced]]
== Advanced File Configurations
  TODO: SHOULD WE COVER?
    .Mule 3 example
    [source,xml, linenums]
    ----
    Mule 3 example goes here.
    ----

    .Mule 4 example
    [source,xml, linenums]
    ----
    Mule 4 example goes here.
    ----
[[transformers_request_response]]
== Migrating Request and Response Transformers
  TODO? use DW instead of a Transformer?
[[metadata_changes]]
== Migrating Metadata
  TODO? Point somewhere re what happened to flowVars, sessionVars, etc.
////

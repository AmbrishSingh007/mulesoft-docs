= About Classloading Isolation

== The Problem

The Mule Runtime engine is developed using Java and many other third party libraries. At the same time, Mule Applications may also contain other Java libraries, but particularly, they will contain extensions that provide most of the integration functionality such as the HTTP connector. +
These extensions can also contain other JAR libraries.

One of the main problems with Java in these scenarios is that as many JARs are placed together, and as each artifact (the runtime, and Mule applications and extensions) are developed and released independently, they may contain conflicting versions of the same jar files. For example, an application may decide to use commons collections 2.1. If later on, we add a new extension that requires commons collections 3.1, the application might not work as expected since commons collections 2.1 and commons collections 3.1 have conflicting resources.

All these problems exist because of the default classloading mechanism of the JVM.

== Mule 3 Solution

Mule 3 provided a partial solution to this problem by a hierarchical organization of classloaders. Applications can see its extensions, the libraries bundled within it, and the runtime libraries; but can't access other application libraries. This solves the problem of resources clashing between different applications, but other conflicts remain, such as libraries from different extensions, extensions libraries with application libraries, and application libraries with the runtime libraries.

== Mule 4 Solution

In Mule 4, the classloading mechanism changed radically to support all the problems depicted previously.

=== API definition

The Mule Runtime and the different artifacts (applications, domains, policies, extensions) need to have a clear API definition. This API definition defines the contract of each artifact and also limits the exposure of the artifact content to other artifacts.

*By defining a clear API for each artifact, we can limit the usage scope of classes and libraries so we can create specific classloaders that do not share everything and avoid clashing.*

==== Mule 4 API

Mule 3 exposes to end users all the classes bundled within its' libraries. This caused problems when upgrading from one runtime to another because changes in the runtime could affect custom Java classes from users.

Mule 4 includes a very well defined API. The runtime is composed of several modules, each serving a different purpose. All of these modules' API combined, define the Mule 4 API. +
Many of these modules serve a very specific purpose, like extending the runtime behavior, and they don't apply to applications or domain development. That's why a Mule API module was created, which users can reference from their applications, domains, or even extensions.
// The API is can be found here.
// _TODO: add link to module and explain a little bit

==== Artifact API

Whenever you create an artifact (application, domain, policy, extension), you need to declare the public API of that module.

===== How to define the public API

Go to link:how-to-export-resources[this page] to learn how to export a resource from an artifact.

===== Considerations

* Resources and classes not exported will not be visible from other artifacts.
* Expose the minimum required set of packages and resources from your artifact.
* Do not export third party libraries unless required.
* Never expose common third party libraries like guava, common-collections, etc. Doing so will cause clashing with other artifacts.
* Ideally, expose only classes from your artifact (or the JDK).

==== Semver

Mule 4 follows https://semver.org/[Semantic Versioning 2.0.0] for all the provided APIs.

==== API restrictions

All public APIs may have restrictions. These restrictions limit how you can use the API. See https://github.com/mulesoft/api-annotations[API annotations module] for more details.

IMPORTANT: You need to take into account the API restrictions defined for the API you are consuming, as they ensure greater flexibility among API changes that can occur between different versions.

=== Classloading Isolation mechanism

Once APIs are clearly defined, we can prevent access to internal classes of the artifact and only make the public API accessible from outside. To protect the APIs Mule 4 uses a custom classloading mechanism.

Suppose you have the following extension file structure:

----
com/example/extension/api/MyClass.class
com/example/extension/internal/Util.class
transformations/customer-to-user.dwl
license.txt
META-INF/mule-artifact/mule-artifact.json
----

And the following `mule-artifact.json` descriptor file for the extension:

[source, json, linenums]
----
{
    "name": "my-test-extension",
    "minMuleVersion": "4.0.0",
    "classLoaderModelLoaderDescriptor": {
        "id": "mule",
        "attributes": {
            "exportedResources": [
                "transformations/customer-to-user.dwl"
            ],
            "exportedPackages": [
                "com/example/extension/api"
            ]
        }
    }
}
----

Then for this extension the following diagram applies:

image:simple_classloading_diagram.png[Simple classloading diagram]

Artifact Class Loader::
    A regular Java Class Loader pointing to the JAR files included in the extension.  This class loader will load all files and classes of the extension.

Artifact Filtering Class Loader::
    A wrapper created over the Artifact Class Loader which will enforce the access restrictions to the extension code for foreign artifacts (the application or other plugins). It uses the content of the `mule-artifact.json` descriptor to know what things are public.

Extension code::
    Here lives the Mule extension code. It uses Artifact Class Loader which does not have any restriction, and it's only able to locate resources of the plugin itself.

Application Code::
    Here lives the Mule application code. It uses the Artifact Filtering Class Loader of the extension to prevent the application from accessing restricted code or resources.

NOTE: This is an oversimplification of the whole mechanism but provides a clear view of how `mule-artifact.json` exported resources are applied within an application.


== See Also

* link:/mule-user-guide/v/3.9/classloader-control-in-mule[Mule 3 classloading]
* link:/mule-sdk/v/1.1/isolation[Mule SDK - About classloading isolation]

//* link:TODO documentation on how the packager automatically export resources

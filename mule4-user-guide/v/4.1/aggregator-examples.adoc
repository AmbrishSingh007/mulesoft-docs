[[aggregators-examples]]
= Aggregators examples
:keywords: aggregators, connector
:toc:
:toc-title:

One common use case for using an aggregator is to store multiple values to then process them as a batch later.
That is easily accomplished by using a size based aggregator.

Suppose that the data that we want to aggregate is a person's name previously stored in a variable with name _personName_ and we want to process batches of 100 elements. Once all the data is collected, we want to execute some logic defined in a flow with the name _whatToDoWithAllTheseNames_.

So, we could use:

[source, xml, linenums]
----
<aggregators:size-based-aggregator name="personsNameAggregator" maxSize="100">
    <aggregators:content>#[vars.personName]</aggregators:content>
    <aggregators:aggregation-complete>
        <flow-ref name="whatToDoWithAllTheseNames"/>
    </aggregators:aggregation-complete>
</aggregators:size-based-aggregator>
----

Now, suppose that we want to execute some action every time our list of names is filled by a 10%. We don't want to do this for every new element because that would mean too many executions. We can assume that the logic to be executed is in another flow named _partialAction_.
We can use the incremental-aggregation route.

[source, xml, linenums]
----
<aggregators:size-based-aggregator name="personsNameAggregator" maxSize="100">
    <aggregators:content>#[vars.personName]</aggregators:content>
    <aggregators:incremental-aggregation>
        <choice>
            <when expression="#[(sizeOf(payload) mod 10) == 0]">
                <flow-ref name="partialAction"/>
            </when>
        </choice>
    </aggregators:incremental-aggregation>
    <aggregators:aggregation-complete>
        <flow-ref name="whatToDoWithAllTheseNames"/>
    </aggregators:aggregation-complete>
</aggregators:size-based-aggregator>
----

But what if we wanted don't want to be waiting forever to fill every batch. We may want to process all the events that we got even if the maxSize was not reached.
There, we can configure a timeout for our aggregator, but taking into account that the aggregation-complete route will not be executed once a timeout happens so we need to include a listener.
We'll set the waiting limit to 10 seconds.

[source, xml, linenums]
----
<aggregators:size-based-aggregator name="personsNameAggregator"
                                   maxSize="100"
                                   timeout="10"
                                   timeoutUnit="SECONDS">
    <aggregators:content>#[vars.personName]</aggregators:content>
    <aggregators:incremental-aggregation>
        <choice>
            <when expression="#[(sizeOf(payload) mod 10) == 0]">
                <flow-ref name="partialAction"/>
            </when>
        </choice>
    </aggregators:incremental-aggregation>
    <aggregators:aggregation-complete>
        <flow-ref name="whatToDoWithAllTheseNames"/>
    </aggregators:aggregation-complete>
</aggregators:size-based-aggregator>
----

And in another flow:
[source, xml, linenums]
----
<aggregators:aggregator-listener aggregatorName="personsNameAggregator" includeTimedOutGroups="true"/>
<flow-ref name="whatToDoWithAllTheseNames"/>
----

Keep in mind that for this cases, the data types that comes out of the aggregation-complete route and out of the aggregator-listener are the same.
So, for the execution of the flow _whatToDoWithAllTheseNames_ it does not matter where the data came from.

Lastly, we realise that we need to do a different processing for every person given it's nationality.
Luckily for us, that information also comes in a variable but we want to process every person from the same country together in the same batch.

We can split them with a group based aggregator.
Let's assume that the person's nationality is previously stored in a variable with name _personNac_.

Our flow should contain this:

[source, xml, linenums]
----
<aggregators:group-based-aggregator name="personsNameByNacAggregator"
                                    groupId="#[vars.personNac]"
                                    groupSize="100"
                                    timeout="10"
                                    timeoutUnit="SECONDS"
                                    evictionTime="0">
    <aggregators:content>#[vars.personName]</aggregators:content>
    <aggregators:incremental-aggregation>
        <choice>
            <when expression="#[(sizeOf(payload) mod 10) == 0]">
                <flow-ref name="partialAction"/>
            </when>
        </choice>
    </aggregators:incremental-aggregation>
    <aggregators:aggregation-complete>
        <flow-ref name="whatToDoWithAllTheseNamesFromSomeCountry"/>
    </aggregators:aggregation-complete>
</aggregators:group-based-aggregator>
----

And we should also add a listener for timeouts:

[source, xml, linenums]
----
<aggregators:aggregator-listener aggregatorName="personsNameByNacAggregator" includeTimedOutGroups="true"/>
<flow-ref name="whatToDoWithAllTheseNamesFromSomeCountry"/>
----

Notice that we did not configure an eviction time in the aggregator. That is because the default value is 0 (Evict right after the group is released)
and is exactly what we want, so that if a group was completed or timed out, some next value can be added to the group without being rejected.


[[see_also]]
== See Also
* link:aggregators-reference[Aggregators Module Documentation Reference]